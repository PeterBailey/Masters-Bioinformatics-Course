```{r echo = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.
source("utils.R", local = TRUE)
```

# Descriptive statistics and plotting


## The Cancer Gene Atlas (TCGA) - Pancreatic Ductal Adenocarcinoma Data Set

To develop a basic understanding of descriptive statistics and plotting we will use data described in [Integrated Genomic Characterization of Pancreatic Ductal Adenocarcinoma. Cancer Cell. 2017;32(2):185-203.e13. doi:10.1016/j.ccell.2017.07.007](https://www.cell.com/cancer-cell/fulltext/S1535-6108(17)30299-4).



The first step is to obtain the relevant data. We are primarily interested in:

   - Gene expression data
   - Clinical data and Transcriptomic subtype annotations

The Bioconductor package [TCGAbiolinks](https://bioconductor.org/packages/release/bioc/html/TCGAbiolinks.html) provides easy to use functions for downloading and analysing data published by The Cancer Genome Atlas (TCGA). A list of TCGA publications can be found here [https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga/publications](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga/publications).

Vignettes describing the `TCGAbiolinks` package can be found using `browseVignettes("TCGAbiolinks")`

The first step of any analysis is to define the libraries that we want to use:

```{r warning=FALSE, message=FALSE}
library(TCGAbiolinks)
library(SummarizedExperiment)
```

The following code segment downloads normalized expression data generated by the TCGA-PAAD project and returns a `RangedSummarizedExperiment` object which we have assigned the name `paad`.

```{r eval=FALSE}
query.exp.hg19 <- GDCquery(project = "TCGA-PAAD",
                  data.category = "Gene expression",
                  data.type = "Gene expression quantification",
                  platform = "Illumina HiSeq", 
                  file.type  = "normalized_results",
                  experimental.strategy = "RNA-Seq",
                  legacy = TRUE)
GDCdownload(query.exp.hg19)
paad <- GDCprepare(query.exp.hg19)

```


```{r echo=FALSE}
paad <- readRDS("RNASeqData/TCGA_paad.Rda")
```

The `paad` object is of class `RangedSummarizedExperiment` which comprises expression data, clinical data and information about the study in which the data was generated.    

```{r}
paad
```


Data within the `RangedSummarizedExperiment` object can be obtained using a number of built-in helper functions which we can identify using the `slotNames` function.

```{r}
slotNames(paad)
```

<br>

### Gene expression data

To access the expression data we use the `assay()$normalized_count` function:

```{r}
normalisedCounts <- assays(paad)$normalized_count
normalisedCounts[1:5, 1:5]
```


<br>


Let's explore `normalisedCounts`

```{r}
class(normalisedCounts)
dim(normalisedCounts)
```

We can see that `normalisedCounts` is of class `matrix` and has 19947 rows (representing genes) and 183 columns (representing the patient samples).


We can extract the expression levels of GATA6 from `normaliseCounts` using the following notation [<rows>, <columns>]:

```{r}
head(normalisedCounts["GATA6", ])
```



### Clinical data



To access the clinical data we can use the `colData()` function:

```{r}
colData(paad)[1:5, 1:5]
```


```{r}
 colnames(colData(paad))[1:20]
```


### PDAC Subtypes



We are interested in obtaining Subtype specific information. The `paad` object comprises Subtype information for the Collisson, Moffitt and Bailey Classification schemes under the following columns:


```{r}
colnames(colData(paad))[grep("subtype_mRNA", colnames(colData(paad)))]
```

Let's extract the subtype information for the Moffitt classification scheme:

```{r}
subtype <- colData(paad)[,"subtype_mRNA.Moffitt.clusters..All.150.Samples..1basal..2classical"]
subtype
```


We want to compare the expression of a specific gene between the Classical and Basal samples. Looking at the `subtype` vector that we have just created there are multiple samples that do not have a Moffitt subtype - designated by `NA`. We need to remove these! 

```{r}
expFinal <- normalisedCounts[,!is.na(subtype)]
subtypeFinal <- subtype[!is.na(subtype)]
subtypeFinal[subtypeFinal == 1] <- "Basal"
subtypeFinal[subtypeFinal == 2] <- "Classical"
subtypeFinal
```


## Descriptive plots


### Boxplots

A common task that we are asked to perform is: Determine whether a given gene is enriched in a specific PDAC subtype.

How do we go about performing such a task and what sort of plots are useful in describing differences between groups?

A popular method to display data involves drawing a box around the first and the third quartile (a bold line segment for the median), and the smaller line segments (whiskers) for the smallest and the largest data values. Such a data display is known as a box-and-whisker plot. 

```{r}
expData <- data.frame(samplename=colnames(expFinal), GATA6=expFinal["GATA6",], 
                      HNF4A=expFinal["HNF4A",], EGFR=expFinal["EGFR",], 
                      S100A2=expFinal["S100A2",], Subtype=subtypeFinal)
head(expData)
```

To generate boxplots we will use the `ggpubr` package of plotting functions, which make generating publication quality plots simple. To generate a boxplot demonstrating the difference in GATA6 gene expression between the Basal and Classical subtypes run the following code snippet: 

```{r fig.cap="GATA6 Boxplot generated using `ggboxplot` coloured by Subtype", fig.width=3.5, fig.height=3.5}
library(ggpubr)
ggboxplot(expData, x = "Subtype", y = "GATA6",
          title = "GATA6 Expression by Subtype", ylab = "Expression",
          color = "Subtype", palette = "jco")
```

We can also generate plots showing the relative expression of multiple genes. Here we combine boxplots for both the GATA6 and HNF4A genes.

```{r fig.cap="Combined Boxplot generated using `ggboxplot` coloured by Subtype", fig.width=6, fig.height=3.5 }
ggboxplot(expData, x = "Subtype", y = c("GATA6","HNF4A"),
          title = "Expression by Subtype", 
          combine = TRUE,
          ylab = "Expression",
          color = "Subtype", palette = "jco")
```

The plotting function `gghistogram` can be used to generate a density histogram of the gene expression values for GATA6 and HNF4A.

```{r fig.cap="Combined density histogram generated using `gghistogram` coloured by Subtype", fig.width=6, fig.height=3.5}
gghistogram(expData,
       x = c("GATA6","HNF4A"),
       y = "..density..",
       combine = TRUE,                  # Combine the 3 plots
       xlab = "Expression", 
       add = "median",                  # Add median line. 
       rug = TRUE,                      # Add marginal rug
       color = "Subtype", 
       fill = "Subtype",
       palette = "jco"
)
```

To determine the statistical significance of the equality of the distributions we can take advantage of the `stat_compare_means` function. First we provide a vector of subtype names that we wish to compare - see `my_comparisons` variable.

```{r fig.cap="Combined Boxplot showing significance generated using `ggboxplot` and `stat_compare_means` coloured by Subtype ", fig.width=6, fig.height=4}
my_comparisons <- list(c("Basal", "Classical"))

ggboxplot(expData, x = "Subtype", y = c("GATA6","HNF4A"),
          title = "Expression by Subtype", 
          combine = TRUE,
          ylab = "Expression",
          color = "Subtype", palette = "jco") +
  stat_compare_means(comparisons = my_comparisons,)
```

What statistical test is being performed? To find a detailed summary of the statistical tests performed, we can use the `compare_means` function.

```{r warning=FALSE, message=FALSE}
compare_means(GATA6 ~ Subtype, data=expData)
```


> ***Exercise 4.1***
>
> Repeat the above analysis using the Bailey classification scheme. How do the classification schemes differ?
>


### Scatter plots


Another common task is to determine the relationship or correlation between the expression of 2 genes. A scatter plot, where expression values for individual genes are positioned along the x and y axes, can be an effective means of describing the correlation between genes. In the following example we will look at genes having positive and negative correlation with GATA6 using the `ggscatter` function. We will also add the statistical significance of the correlation using the `stat_cor` function and include the regression line and confidence interval.

First let's identify genes that are positively and negatively correlated with GATA6.

```{r warning=FALSE, message=FALSE}
#Calculate the spearman correlation 
corGenes <- apply(expFinal, 1, function(i){
  cor(expFinal["GATA6",],i, method = "spearman")
})
#Identify top negatively correlated genes
head(corGenes[order(corGenes)])
#Identify top positively correlated genes
head(corGenes[order(corGenes, decreasing = TRUE)])
corData <- data.frame(samplename=colnames(expFinal), GATA6=expFinal["GATA6",], 
                       ADAM19=expFinal["ADAM19",], C9orf152=expFinal["C9orf152",], Subtype=subtypeFinal)
```

Now produce a scatter plot showing the correlation for a negatively correlated gene.
```{r fig.cap="Correlation bewteen the expression of GATA6 and ADAM19 using `ggscatter` and `stat_cor` coloured by Subtype ", fig.width=4, fig.height=4}
ggscatter(corData, x = "GATA6", y = "ADAM19", size = 0.6, 
          rug = TRUE, # Add marginal rug
          add = "reg.line", conf.int = TRUE) +
  stat_cor(method = "spearman")
```

Now produce a scatter plot showing the correlation for a positively correlated gene.
```{r fig.cap="Correlation bewteen the expression of GATA6 and C9orf152 using `ggscatter` and `stat_cor` coloured by Subtype ", fig.width=4, fig.height=4}
ggscatter(corData, x = "GATA6", y = "C9orf152", size = 0.6, 
          rug = TRUE, # Add marginal rug
          add = "reg.line", conf.int = TRUE) +
  stat_cor(method = "spearman")
```


> ***Exercise 4.2***
>
> Are these genes significantly associated with the Classical or Basal subtype? 
> Refering to Figure 4.7, select genes that either cluster together or separately and generate a correlation plot as above.
>




### Hierarchical Clustering

Clustering is a common analysis performed for gene expression data. The most often performed clustering method is hierarchical clustering, which typically takes the form of a heatmap.

We will first compute the Pearson correlation between the genes. Note that we must operate on the transpose of the matrix because the R function `cor()` operates on the columns.

Before computing the Pearson correlation let's reduce the size of our gene expression matrix to the 100 most variable genes.

```{r}
# First create a helper function
rnaSelectTopVarGenes <- function(normCounts, n=2000){
  mad <- apply(normCounts, 1, mad)
  ords <- names(sort(mad, decreasing=TRUE))
  select <- normCounts[ords[1:n],]
  select
}

top100 <- rnaSelectTopVarGenes(expFinal, n=100)

rownames(top100)[1:20]
```

Now we can compute the Pearson correlation between these genes.

```{r}
genes.cor <- cor(t(top100), use="pairwise.complete.obs", method="pearson")
genes.cor[1:10,1:10]
```

The Pearson correlation coefficient is a similarity metric, values of which vary from -1 (perfect anti-correlation) to +1 (perfect correlation), see Lectures Chap.1. Pearson's correlation can be transformed into a distance metric by subtracting from 1. The Pearson distance would then vary from 0 (perfect correlation) to 2 (perfect anti-correlation). Hierarchical clustering of the Pearson distance metric can be achieved by the `hclust()` function. We will use the `average` linkage as an agglomeration rule. 


```{r fig.cap="Gene clustering by Pearson distance and average linkage", fig.width=9, fig.height=4}
genes.cor.dist <- as.dist(1-genes.cor)
genes.tree <- hclust(genes.cor.dist, method='average')
plot(genes.tree, xlab=NULL, cex=0.5)
```

> ***Exercise 4.3***
>
> What do you observe? Does the clustering make any sense?
>

A question that we might ask is whether the top 100 variable genes can discriminate Classical and Basal subtypes? We can answer this question by performing hierarchical clustering. To make our results a little easier to interpret let's modify our `top100` matrix by switching the column names to the PDAC subtype designations.

```{r}
colnames(top100) <- subtypeFinal
colnames(top100)[1:10]
```


Next let's compute correlations between samples by using the Spearman rank as the metric. 

```{r fig.cap="Sample clustering by Spearman distance and average linkage", fig.width=10, fig.height=4}
samples.cor.spearman <- cor(top100,use="pairwise.complete.obs", method="spearman") 
samples.cor.spearman.dist <- as.dist(1-samples.cor.spearman)
samples.tree <- hclust(samples.cor.spearman.dist, method='average')
plot(samples.tree, cex=0.5, xlab=NULL)
```

> ***Exercise 4.4***
>
> What do you observe?
> Are the top 100 variables good at descriminating Classical from Basal samples?
> Would increasing the number of variable genes to 1000 help?
> What other agglomeration methods may be used with the hclust method?
>

### Hierarchical clustering using the Moffitt transcriptomic signature

Based on our previous clustering analysis, the top 100 most variable genes were not very good at discriminating the Classical and Basal samples. Let's now use the genes that make up the Moffitt signature - this should allow us to classify the samples correctly!

First we subset the `expFinal` matrix using the Moffitt classifier genes.

```{r}
mSig <- read.csv("course/Moffitt_gene_signature.csv", stringsAsFactors = FALSE)
head(mSig)
dim(mSig)
expFinalSig <- expFinal[rownames(expFinal) %in% mSig$symbol,]
dim(expFinal)
dim(expFinalSig)
```


Let's now compute correlations between samples by using the Spearman rank as the metric, as before!


```{r fig.cap="Sample clustering by Spearman distance and average linkage using Moffitt gene signature", fig.width=10, fig.height=4}
#Set column names to Subtypes
colnames(expFinalSig) <- subtypeFinal
#Perform clustering
samples.cor.spearman <- cor(expFinalSig,use="pairwise.complete.obs", method="spearman") 
samples.cor.spearman.dist <- as.dist(1-samples.cor.spearman)
samples.tree <- hclust(samples.cor.spearman.dist, method='average')
plot(samples.tree, cex=0.5, xlab=NULL)
```

> ***Exercise 4.5***
>
> What do you observe? Can we now descriminate Classical from Basal patient samples?
>

### Heatmaps

Hierarchical clustering methods enable hierarchical representations of a measure of dissimilarity between groups of observations (i.e. groups of genes and groups of patients in our PAAD example). The measure of dissimilarity is based on pairwise dissimilarities among the observations in the two groups.

In the context of microarray or RNAseq data, a heatmap arranges both the rows and the columns of the expression matrix in orderings derived from hierarchical clustering. By cutting the dendrograms at various heights, different number of clusters emerge and the set of clusters are nested within one another. 

For our first example we will use the `expFinalSig` matrix representing genes defining the Moffitt classification scheme. The `ComplexHeatmap` and `circlize` packages will do the majority of the work! In this example we will generate an annotation track above the heatmap to show which samples are Classical and which are Basal.

```{r fig.cap="Heatmap using Moffitt gene signature", fig.width=8, fig.height=9}
library(ComplexHeatmap)
library(circlize)
#First we scale the matrix
expFinalSig <- t(scale(t(expFinalSig)))
#Generate a list of colours to map to the Subtypes
colors <- RColorBrewer::brewer.pal(8, "Set1")
#Generate the annotation
ha <- HeatmapAnnotation(Moffitt = subtypeFinal,
                        col = list(Moffitt = structure(names = c(
                          "Classical", "Basal"
                        ), colors[1:2])))
#Generate the heatmap
Heatmap(
  expFinalSig,
  col = colorRamp2(c(-2, 0, 2), c("#377EB8", "white", "#E41A1C")),
  name = "Z score",
  cluster_columns = TRUE,
  cluster_rows = TRUE,
  top_annotation = ha,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 5)
)
```


We seem to be getting a good separation of the samples but it would be nice to have all of the Classical and Basal samples grouped together. Let's first sort the `subtypeFinal` vector and columns of the `expFinalSig` matrix into their respective subtypes and regenerate the heatmap.

```{r fig.cap="Heatmap using Moffitt gene signature ordered by subtype", fig.width=8, fig.height=9}
head(order(subtypeFinal, decreasing = TRUE))
subOrdered <- subtypeFinal[order(subtypeFinal, decreasing = TRUE)]
expFinalSigOrd <- expFinalSig[, order(subtypeFinal, decreasing = TRUE)]
#Make the sample annotation track
ha <- HeatmapAnnotation(Moffitt = subOrdered,
                        col = list(Moffitt = structure(names = c(
                          "Classical", "Basal"
                        ), colors[1:2])))
#Generate the heatmap
Heatmap(
  expFinalSigOrd ,
  col = colorRamp2(c(-2, 0, 2), c("#377EB8", "white", "#E41A1C")),
  name = "Z score",
  cluster_columns = FALSE, #Turned clustering of columns off!!!
  cluster_rows = TRUE,
  top_annotation = ha,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 5)
)
```


Let's also annotate genes that discriminate the subtypes. To do this we will use the `Heatmap` _split_ argument.


```{r fig.cap="Heatmap using Moffitt gene signature ordered by subtype and with gene annotations", fig.width=8, fig.height=9}
#Map matrix gene names to subtype
partition <- rep(NA, nrow(expFinalSig))
partition[rownames(expFinalSig) %in% mSig$symbol[mSig$Group == "Basal-like"]] <- "Basal"
partition[rownames(expFinalSig) %in% mSig$symbol[mSig$Group == "Classical"]] <- "Classical"
head(partition)
#Make the sample annotation track
ha <- HeatmapAnnotation(Moffitt = subOrdered,
                        col = list(Moffitt = structure(names = c(
                          "Classical", "Basal"
                        ), colors[1:2])))
#Generate the heatmap
Heatmap(
  expFinalSigOrd ,
  col = colorRamp2(c(-2, 0, 2), c("#377EB8", "white", "#E41A1C")),
  name = "Z score",
  cluster_columns = FALSE, #Turned clustering of columns off!!!
  cluster_rows = TRUE,
  top_annotation = ha,
  split=partition, #added a partition argument
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 5)
)
```


> ***Exercise 4.6***
>
> Add the Collisson and Bailey subtype designations to the Heatmap annotation track! How do they compare?
>

