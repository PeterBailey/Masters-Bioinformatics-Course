[["index.html", "PGT Bioinformatics Course Chapter 1 Prerequisites 1.1 Installing R and RStudio 1.2 Installing R and Bioconductor packages 1.3 Loading R and Bioconductor packages 1.4 Learning resources", " PGT Bioinformatics Course Peter J. Bailey 2021-07-19 Chapter 1 Prerequisites This book provides an introductory course in R programming. It is primarily designed for wet lab biologists who are interested in developing core skills in the R programming language and who would like to analyze their own RNAseq data! 1.1 Installing R and RStudio To complete this course you will need to install R and RStudio on your local machine. Detailed instructions on how to install R and RStudio are provided in “Hands-on programming with R”. Please make sure that R Version &gt;=3.6.1 is installed on your local machine. Hands-on programming with R is an excellent open source reference for learning the basics of R and can be used as a companion to this course. Please also find additional learning resources below that can be used as companions to this course. We will use RStudio in this course. RStudio is an integrated development environment (IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management. Figure 1.1: The RStudio IDE for R. 1.2 Installing R and Bioconductor packages CRAN (the Comprehensive R Archive Network) is a repository of packages for R, and it is mirrored on many servers around the world. It is the default repository system used by R. You can install a package from CRAN by using install.packages(). To install ggplot2 use: install.packages(&quot;ggplot2&quot;) If you are prompted to select a download mirror use the first choice, https://cloud.r-project.org/. You can also install multiple packages at once by passing the function a vector of package names: install.packages(c(&quot;ggplot2&quot;, &quot;tidyverse&quot;)) Once you have R/RStudio up and running please also install Bioconductor. Bioconductor is a repository of R packages for analyzing genomic data! Bioconductor can be installed easily using the following script: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(version = &quot;3.12&quot;) Individual packages of interest can then be installed as follows: BiocManager::install(&quot;DESeq2&quot;) Multiple packages of interest can be installed as follows: BiocManager::install(c(&quot;DESeq2&quot;, &quot;ggpubr&quot;, &quot;ComplexHeatmap&quot;, &quot;circlize&quot;, &quot;clusterProfiler&quot;)) Each Bioconductor package contains at least one vignette, a document that provides a task-oriented description of package functionality. Vignettes contain executable examples and are intended to be used interactively. You can access the PDF version of a vignette for any installed package from inside R using the browseVignettes() function. To view documentation about the DESeq2 package you can use the following R function: browseVignettes(&quot;DESeq2&quot;) 1.3 Loading R and Bioconductor packages To load an R package that has been installed on your local machine use the library() function. For example, to load the ggplot2 package run: library(ggplot2) 1.4 Learning resources There are a multitude of learning resources for the R programming language. Here are just a few noteworthy examples that are entirely open source!!! Wim P. Krijnen (2009) Applied Statistics for Bioinformatics using R R &amp; Bioconductor Manual Hands-on programming with R R for Data Science R Graphics Cookbook 2nd Edition The book is written in RMarkdown with bookdown. "],["intro.html", "Chapter 2 Introduction 2.1 Course outline", " Chapter 2 Introduction 2.1 Course outline The course is divided into 2 parts. PART 1 will teach you the basics of R programming, computational statistics and its application in solving real world biological problems. PART 2 will teach you how to analyse RNAseq data and will provide informatic workflows that you can use in your current research. This course is extremely condensed and you are not expected to complete all tasks before or during the 3 day meeting. We will work through coded examples together. Additional tutorials may be scheduled after meeting close, if ESRs feel that this is necessary! Please also note that this course material comprises embeded video content which is best viewed using a CHROME web browser 2.1.1 PART 1 PART 1 is provided in a separate workbook Applications of Computational Statistics. Students are encouraged to at least go through PART 1 before the commencement of the course. By the end of PART 1, you should be able to: Understand basic statistical concepts Perform statistical tests to answer simple to more complex biological questions Mine and explore biological data sets Process microarray data and perform statistical analysis Be able to use the R statistical programming language The following topics are covered in PART 1: Data description Visualizing distributions Measures of central tendency and variability Q-Q plot Boxplots Correlation measures Probability distribution Probability distribution on discrete random variables (binomial, Poisson) Probability distribution on continuous random variables (normal, z, t-, chi-squared, F) Statistical tests Hypothesis testing Statistical tests with continuous variables one sample, two samples, equal and unequal variances F-test and ANOVA Statistical tests with categorical variables Multiple testing Clustering distance definition hierarchical clustering k-means SOM Principal component analysis Analysis of microarray data normalization transformation statistical tests 2.1.1.1 Practicals Practical workbooks are also provided: Programming with Applications in R: an introduction Programming with Applications in Bioconductor: an introduction Data resources used for the Practicals are provided below: Comprehensive molecular portraits of human breast tumours Breast Cancer dataset (eSet.RData) AML dataset (Golub.RData) Practicals P0.1 and P0.2 test R programming basics. Practicals P1 to P7 provide details on how one can apply descriptive statistics to the analysis of transcriptomic data. P1 to P5.3 include exercises as part of assignments A1 and A3 The following topics are covered in the practical component of PART 1: P0.1. Introduction to R + Getting started + Vectors + Matrices P0.2. Intro to R continued + Lists + Data frames + Factors and tables P1. Graphical outputs P2. Statistical tests P3. Clustering P4. PCA P5. Analysis of microarray data 1/3 P6. Analysis of microarray data 2/3 P7. Analysis of microarray data 3/3 2.1.1.2 Assessment Students are encouraged to have at least gone through the assignments before the commencement of the course. Assignments A1 and A3 are provided below. We will work through the assignment corrections on Day 3. Assignments Assignment 1 Assessing R skills &amp; interpretation of statistical tests - Starts in P1 (covers up to P3) Assignment 2 (Optional): Review and explanation of statistical analysis from a scientific article of the student’s choice . The student should choose a recently published scientific article and explain the aim of the study and how the statistical analyses were performed. Assignment 3 Assessing statistical analyses using data described in Comprehensive molecular portraits of human breast tumours. This assignment will be broken into different exercises covering the content of the pracs P4 to P8 and will be handed at each prac. Starts in P4 (covers up to P8) 2.1.2 PART 2 This part of the course will provide steps for the analysis of RNASeq data. To bring this part of the course into real world focus we will re-analyse RNAseq data published in Brunton et al. HNF4A and GATA6 Loss Reveals Therapeutically Actionable Subtypes in Pancreatic Cancer. Cell Reports 2020 Students should have read Brunton et al and be familiar with the analyses performed therein before the start of the course. PART 2 of this course will be delivered live. We will work through the coded examples together! By the end of PART 2, you should be able to: Use the nf-core/rnaseq bioinformatic workflow to map raw RNAseq reads, assess RNAseq QC and generate count files for downstream analysis Perform PCA/Hierarchical clustering of normalized RNAseq data Perform Differential Gene Expression analysis Generate publication quality heatmaps and statistical plots Perform Gene Set Enrichment analysis to identify significantly enriched biological pathways Subtype PDAC using pre-defined transcriptional signatures "],["r-programming-language-primer.html", "Chapter 3 R Programming language primer 3.1 Vectors 3.2 Matrix 3.3 Data Frame 3.4 Factors 3.5 List 3.6 Array 3.7 Creating functions 3.8 Loading Data 3.9 Saving Data 3.10 Saving plots", " Chapter 3 R Programming language primer The R programming language comprises 6 major types of R objects Vectors Matrix Data Frame Lists Array Factors 3.1 Vectors The vector type is the fundamental data type in R. The elements of a vector must all have the same mode (data type) of the following type: Scalars are individual numbers, they actually are one-element vectors e.g. x &lt;- 10 Character strings are single-element vectors of mode ”character” e.g. y &lt;- \"hello\" x &lt;- c(1, 2, 3, 4, 5, 6) x #&gt; [1] 1 2 3 4 5 6 x &lt;- 1:6 x #&gt; [1] 1 2 3 4 5 6 x[1] #&gt; [1] 1 text &lt;- c(&quot;Hello&quot;, &quot;World&quot;) text #&gt; [1] &quot;Hello&quot; &quot;World&quot; names(x) &lt;- paste(&quot;name&quot;, 1:6, sep=&quot;&quot;) x #&gt; name1 name2 name3 name4 name5 name6 #&gt; 1 2 3 4 5 6 3.1.1 Vectors in action z_scores &lt;- seq(-3, 3, by = .1) z_scores #&gt; [1] -3.0 -2.9 -2.8 -2.7 -2.6 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 #&gt; [15] -1.6 -1.5 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 -0.4 -0.3 #&gt; [29] -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 #&gt; [43] 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 #&gt; [57] 2.6 2.7 2.8 2.9 3.0 norm.dist &lt;- dnorm(z_scores) norm.dist #&gt; [1] 0.004431848 0.005952532 0.007915452 0.010420935 0.013582969 0.017528300 #&gt; [7] 0.022394530 0.028327038 0.035474593 0.043983596 0.053990967 0.065615815 #&gt; [13] 0.078950158 0.094049077 0.110920835 0.129517596 0.149727466 0.171368592 #&gt; [19] 0.194186055 0.217852177 0.241970725 0.266085250 0.289691553 0.312253933 #&gt; [25] 0.333224603 0.352065327 0.368270140 0.381387815 0.391042694 0.396952547 #&gt; [31] 0.398942280 0.396952547 0.391042694 0.381387815 0.368270140 0.352065327 #&gt; [37] 0.333224603 0.312253933 0.289691553 0.266085250 0.241970725 0.217852177 #&gt; [43] 0.194186055 0.171368592 0.149727466 0.129517596 0.110920835 0.094049077 #&gt; [49] 0.078950158 0.065615815 0.053990967 0.043983596 0.035474593 0.028327038 #&gt; [55] 0.022394530 0.017528300 0.013582969 0.010420935 0.007915452 0.005952532 #&gt; [61] 0.004431848 mean(norm.dist) #&gt; [1] 0.1635609 median(norm.dist) #&gt; [1] 0.1295176 sd(norm.dist) #&gt; [1] 0.140773 3.2 Matrix A matrix is a rectangular array of numbers (technically a vector with a number of rows and a number of columns) m &lt;- matrix(x, nrow = 2) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 m &lt;- matrix(x, nrow = 2, byrow = TRUE) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 3.2.1 Matrices in action normMat &lt;- matrix(rnorm(10),nrow=5,ncol=20) normMat[1:5,1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.5830124 0.8816304 0.5830124 0.8816304 0.5830124 #&gt; [2,] 1.3631832 -0.2371296 1.3631832 -0.2371296 1.3631832 #&gt; [3,] 0.6114917 -0.9639327 0.6114917 -0.9639327 0.6114917 #&gt; [4,] 0.2529515 1.1138404 0.2529515 1.1138404 0.2529515 #&gt; [5,] -0.8771275 0.9611013 -0.8771275 0.9611013 -0.8771275 rownames(normMat) &lt;- paste(&quot;Gene&quot;, 1:5, sep=&quot;_&quot;) normMat[1:5,1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; Gene_1 0.5830124 0.8816304 0.5830124 0.8816304 0.5830124 #&gt; Gene_2 1.3631832 -0.2371296 1.3631832 -0.2371296 1.3631832 #&gt; Gene_3 0.6114917 -0.9639327 0.6114917 -0.9639327 0.6114917 #&gt; Gene_4 0.2529515 1.1138404 0.2529515 1.1138404 0.2529515 #&gt; Gene_5 -0.8771275 0.9611013 -0.8771275 0.9611013 -0.8771275 #Calculate mean for each matrix row apply(normMat, MARGIN=1, mean) #&gt; Gene_1 Gene_2 Gene_3 Gene_4 Gene_5 #&gt; 0.73232138 0.56302682 -0.17622047 0.68339593 0.04198691 #Calculate mean for each matrix column apply(normMat, MARGIN=2, mean) #&gt; [1] 0.3867023 0.3511020 0.3867023 0.3511020 0.3867023 0.3511020 0.3867023 #&gt; [8] 0.3511020 0.3867023 0.3511020 0.3867023 0.3511020 0.3867023 0.3511020 #&gt; [15] 0.3867023 0.3511020 0.3867023 0.3511020 0.3867023 0.3511020 3.3 Data Frame A data frame is a data set that contains data of different modes (i.e. different types). A data frame is a list with each component of a list being a vector corresponding to a column in the data. df &lt;- data.frame(cancerType = c(&quot;PDAC&quot;, &quot;PDAC&quot;, &quot;PDAC&quot;), KRAS_status = c(&quot;wt&quot;, &quot;mut&quot;, &quot;mut&quot;), Subtype = c(&quot;Classical&quot;, &quot;Classical&quot;, &quot;Subtype&quot;)) df #&gt; cancerType KRAS_status Subtype #&gt; 1 PDAC wt Classical #&gt; 2 PDAC mut Classical #&gt; 3 PDAC mut Subtype 3.3.1 Data Frames in action #Extract cancerType df[,1] #&gt; [1] PDAC PDAC PDAC #&gt; Levels: PDAC #Extract cancerType df$cancerType #&gt; [1] PDAC PDAC PDAC #&gt; Levels: PDAC #Assigning new data df$Sex &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;) df #&gt; cancerType KRAS_status Subtype Sex #&gt; 1 PDAC wt Classical Male #&gt; 2 PDAC mut Classical Female #&gt; 3 PDAC mut Subtype Male #Excluding factors df &lt;- data.frame(cancerType = c(&quot;PDAC&quot;, &quot;PDAC&quot;, &quot;PDAC&quot;), KRAS_status = c(&quot;wt&quot;, &quot;mut&quot;, &quot;mut&quot;), Subtype = c(&quot;Classical&quot;, &quot;Classical&quot;, &quot;Subtype&quot;), stringsAsFactors = FALSE) df$cancerType #&gt; [1] &quot;PDAC&quot; &quot;PDAC&quot; &quot;PDAC&quot; 3.4 Factors Factors are used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting. subtype &lt;- factor(c(&quot;Classical&quot;, &quot;Basal&quot;, &quot;Basal&quot;, &quot;Classical&quot;)) subtype #&gt; [1] Classical Basal Basal Classical #&gt; Levels: Basal Classical levels(subtype) #&gt; [1] &quot;Basal&quot; &quot;Classical&quot; table(subtype) #&gt; subtype #&gt; Basal Classical #&gt; 2 2 3.4.1 Factors in action colours &lt;- c(&quot;red&quot;, &quot;green&quot;) colours[subtype] #&gt; [1] &quot;green&quot; &quot;red&quot; &quot;red&quot; &quot;green&quot; 3.5 List Lists can contain items comprising different data types and are similar to a C struct in C++. list1 &lt;- list(1:20, &quot;KRAS&quot;, list(1:6, 7:10)) list1 #&gt; [[1]] #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #&gt; #&gt; [[2]] #&gt; [1] &quot;KRAS&quot; #&gt; #&gt; [[3]] #&gt; [[3]][[1]] #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; [[3]][[2]] #&gt; [1] 7 8 9 10 3.5.1 Lists in action list2 &lt;- list(rnorm(10), rnorm(10), rnorm(10)) #Access first entry of list2 list2[1] #&gt; [[1]] #&gt; [1] 0.5271576 1.3340916 0.1459636 -0.4157415 -0.3883971 -0.9461401 #&gt; [7] 0.7620549 -0.2837477 0.2434877 -0.5203084 #Access vector of values in first entry of list2 list2[[1]] #&gt; [1] 0.5271576 1.3340916 0.1459636 -0.4157415 -0.3883971 -0.9461401 #&gt; [7] 0.7620549 -0.2837477 0.2434877 -0.5203084 #Finding mean for each vector series in list2 - returns a list of means lapply(list2, mean) #&gt; [[1]] #&gt; [1] 0.04584205 #&gt; #&gt; [[2]] #&gt; [1] 0.2392012 #&gt; #&gt; [[3]] #&gt; [1] -0.5920434 #Finding mean for each vector series in list2 - returns a vector of means sapply(list2, mean) #&gt; [1] 0.04584205 0.23920117 -0.59204341 3.6 Array Arrays are matrices with more than 2 dimensions. ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3)) ar #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 11 13 #&gt; [2,] 12 14 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 21 23 #&gt; [2,] 22 24 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] #&gt; [1,] 31 33 #&gt; [2,] 32 34 3.7 Creating functions #Function to select the top n most variable genes rnaSelectTopVarGenes &lt;- function(normCounts, n=2000){ mad &lt;- apply(normCounts, 1, mad) ords &lt;- names(sort(mad, decreasing=TRUE)) select &lt;- normCounts[ords[1:n],] select } top2varGenes &lt;- rnaSelectTopVarGenes(normMat, n=2) head(top2varGenes) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; Gene_5 -0.8771275 0.9611013 -0.8771275 0.9611013 -0.8771275 0.9611013 #&gt; Gene_2 1.3631832 -0.2371296 1.3631832 -0.2371296 1.3631832 -0.2371296 #&gt; [,7] [,8] [,9] [,10] [,11] [,12] #&gt; Gene_5 -0.8771275 0.9611013 -0.8771275 0.9611013 -0.8771275 0.9611013 #&gt; Gene_2 1.3631832 -0.2371296 1.3631832 -0.2371296 1.3631832 -0.2371296 #&gt; [,13] [,14] [,15] [,16] [,17] [,18] #&gt; Gene_5 -0.8771275 0.9611013 -0.8771275 0.9611013 -0.8771275 0.9611013 #&gt; Gene_2 1.3631832 -0.2371296 1.3631832 -0.2371296 1.3631832 -0.2371296 #&gt; [,19] [,20] #&gt; Gene_5 -0.8771275 0.9611013 #&gt; Gene_2 1.3631832 -0.2371296 3.8 Loading Data Loading data from a comma separated file can be easily achieved using the read.delim or read.csv functions. There are many alternatives! moffitt &lt;- read.delim(&quot;course/Moffitt_gene_signature.csv&quot;, sep=&quot;,&quot;, stringsAsFactors = FALSE) head(moffitt) #&gt; symbol Group #&gt; 1 MUC13 Classical #&gt; 2 GPR35 Classical #&gt; 3 USH1C Classical #&gt; 4 BAIAP2L2 Classical #&gt; 5 GAL3ST1 Classical #&gt; 6 VIL1 Classical class(moffitt) #&gt; [1] &quot;data.frame&quot; moffitt$symbol #&gt; [1] &quot;MUC13&quot; &quot;GPR35&quot; &quot;USH1C&quot; &quot;BAIAP2L2&quot; &quot;GAL3ST1&quot; #&gt; [6] &quot;VIL1&quot; &quot;DDC&quot; &quot;LGALS4&quot; &quot;TSPAN8&quot; &quot;SLC5A1&quot; #&gt; [11] &quot;SEMA4G&quot; &quot;TNFRSF11A&quot; &quot;HSD17B2&quot; &quot;CKMT1A&quot; &quot;DPCR1&quot; #&gt; ... #&gt; [76] &quot;REEP3&quot; &quot;DCBLD2&quot; &quot;NMB&quot; &quot;IKZF2&quot; &quot;GPR87&quot; #&gt; [81] &quot;MUC16&quot; &quot;IVL&quot; &quot;SPRR1B&quot; &quot;BCAR3&quot; &quot;TTC9&quot; #&gt; [86] &quot;PTGES&quot; &quot;CST6&quot; &quot;CATSPER1&quot; 3.9 Saving Data Saving data is also simple. You can write data to comma separated (csv) files using the write.table function. The best way to store objects from R is within .RData files. .RData files are specific to R and can store as many objects as required. #Write data to a tab separate file called Moffitt_gene_signature.tsv write.table(moffitt, &quot;course/Moffitt_gene_signature.tsv&quot;, sep=&quot;\\t&quot;, quote = FALSE, row.names = FALSE) #Save moffitt to a RData file called moffittSig.RData save(moffitt,x,y,z,file=&quot;course/moffittSig.RData&quot;) #Load themoffitt data.frame into the current environment load(&quot;course/moffittSig.RData&quot;) 3.10 Saving plots How do we save complex plots like the one below? df &lt;- 6 - 1 f &lt;- function(x) { dt(x, df) } plot(f, -4, 4, xlab = &quot;x-axis&quot;, ylab = &quot;T Density dt(x)&quot;) ci &lt;- c(qt(0.025, df), qt(0.975, df)) x &lt;- seq(-4, ci[1], 0.01) y &lt;- seq(ci[2], 4, 0.01) polygon(c(ci[1], x, ci[1]), c(0, 0, f(x)), col = &quot;red&quot;) polygon(c(ci[2], y, ci[2]), c(f(y), 0, 0), col = &quot;red&quot;) arrows(-3, 0.25, -3, 0.05) text(-3, 0.3, &quot;Rejection Region&quot;) arrows(3, 0.25, 3, 0.05) text(3, 0.3, &quot;Rejection Region&quot;) arrows(0, 0.15, 0, 0.05) text(0, 0.2, &quot;Acceptance Region&quot;) Figure 3.1: Acceptance and rejection regions in a t-test distribution. It is easy to save the above plot using the pdf() and dev.off() functions as follows. All of the plotting commands contained between the pdf() &amp; dev.off() functions will be sent to file. It is also possible to use the png() function if you would like to create png’s instead! Check out the grDevices package for other alternatives. pdf(&quot;course/normalDist.pdf&quot;, height=6, width=4) df &lt;- 6 - 1 f &lt;- function(x) { dt(x, df) } plot(f, -4, 4, xlab = &quot;x-axis&quot;, ylab = &quot;T Density dt(x)&quot;) ci &lt;- c(qt(0.025, df), qt(0.975, df)) x &lt;- seq(-4, ci[1], 0.01) y &lt;- seq(ci[2], 4, 0.01) polygon(c(ci[1], x, ci[1]), c(0, 0, f(x)), col = &quot;red&quot;) polygon(c(ci[2], y, ci[2]), c(f(y), 0, 0), col = &quot;red&quot;) arrows(-3, 0.25, -3, 0.05) text(-3, 0.3, &quot;Rejection Region&quot;) arrows(3, 0.25, 3, 0.05) text(3, 0.3, &quot;Rejection Region&quot;) qrrows(0, 0.15, 0, 0.05) text(0, 0.2, &quot;Acceptance Region&quot;) dev.off() "],["descriptive-statistics-and-plotting.html", "Chapter 4 Descriptive statistics and plotting 4.1 The Cancer Gene Atlas (TCGA) - Pancreatic Ductal Adenocarcinoma Data Set 4.2 Descriptive plots", " Chapter 4 Descriptive statistics and plotting 4.1 The Cancer Gene Atlas (TCGA) - Pancreatic Ductal Adenocarcinoma Data Set To develop a basic understanding of descriptive statistics and plotting we will use data described in Integrated Genomic Characterization of Pancreatic Ductal Adenocarcinoma. Cancer Cell. 2017;32(2):185-203.e13. doi:10.1016/j.ccell.2017.07.007. The first step is to obtain the relevant data. We are primarily interested in: Gene expression data Clinical data and Transcriptomic subtype annotations The Bioconductor package TCGAbiolinks provides easy to use functions for downloading and analysing data published by The Cancer Genome Atlas (TCGA). A list of TCGA publications can be found here https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga/publications. Vignettes describing the TCGAbiolinks package can be found using browseVignettes(\"TCGAbiolinks\") The first step of any analysis is to define the libraries that we want to use: library(TCGAbiolinks) library(SummarizedExperiment) The following code segment downloads normalized expression data generated by the TCGA-PAAD project and returns a RangedSummarizedExperiment object which we have assigned the name paad. query.exp.hg19 &lt;- GDCquery(project = &quot;TCGA-PAAD&quot;, data.category = &quot;Gene expression&quot;, data.type = &quot;Gene expression quantification&quot;, platform = &quot;Illumina HiSeq&quot;, file.type = &quot;normalized_results&quot;, experimental.strategy = &quot;RNA-Seq&quot;, legacy = TRUE) GDCdownload(query.exp.hg19) paad &lt;- GDCprepare(query.exp.hg19) The paad object is of class RangedSummarizedExperiment which comprises expression data, clinical data and information about the study in which the data was generated. paad #&gt; class: RangedSummarizedExperiment #&gt; dim: 19947 183 #&gt; metadata(1): data_release #&gt; assays(1): normalized_count #&gt; rownames(19947): A1BG A2M ... TICAM2 SLC25A5-AS1 #&gt; rowData names(3): gene_id entrezgene ensembl_gene_id #&gt; colnames(183): TCGA-3A-A9I7-01A-21R-A38C-07 #&gt; TCGA-IB-7885-01A-11R-2156-07 ... TCGA-IB-7888-01A-11R-2156-07 #&gt; TCGA-F2-A44H-01A-11R-A26U-07 #&gt; colData names(122): sample patient ... #&gt; subtype_Year.of.tobacco.smoking.onset subtype_patient Data within the RangedSummarizedExperiment object can be obtained using a number of built-in helper functions which we can identify using the slotNames function. slotNames(paad) #&gt; [1] &quot;rowRanges&quot; &quot;colData&quot; &quot;assays&quot; &quot;NAMES&quot; #&gt; [5] &quot;elementMetadata&quot; &quot;metadata&quot; 4.1.1 Gene expression data To access the expression data we use the assay()$normalized_count function: normalisedCounts &lt;- assays(paad)$normalized_count normalisedCounts[1:5, 1:5] #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 TCGA-IB-7885-01A-11R-2156-07 #&gt; A1BG 67.4598 46.5184 #&gt; A2M 14601.7751 20869.5846 #&gt; NAT1 222.3161 155.7439 #&gt; NAT2 208.3686 11.7479 #&gt; RP11-986E7.7 8514.7929 24899.2196 #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 TCGA-2L-AAQJ-01A-12R-A39D-07 #&gt; A1BG 81.9122 91.5297 #&gt; A2M 19703.8049 15670.2079 #&gt; NAT1 119.5122 148.5149 #&gt; NAT2 71.2195 23.7624 #&gt; RP11-986E7.7 9787.8049 15188.1188 #&gt; TCGA-2J-AABV-01A-12R-A41B-07 #&gt; A1BG 105.5118 #&gt; A2M 11981.9528 #&gt; NAT1 67.7165 #&gt; NAT2 0.0000 #&gt; RP11-986E7.7 158891.3543 Let’s explore normalisedCounts class(normalisedCounts) #&gt; [1] &quot;matrix&quot; dim(normalisedCounts) #&gt; [1] 19947 183 We can see that normalisedCounts is of class matrix and has 19947 rows (representing genes) and 183 columns (representing the patient samples). We can extract the expression levels of GATA6 from normaliseCounts using the following notation [, ]: head(normalisedCounts[&quot;GATA6&quot;, ]) #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 TCGA-IB-7885-01A-11R-2156-07 #&gt; 628.0642 742.8044 #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 TCGA-2L-AAQJ-01A-12R-A39D-07 #&gt; 1664.3902 1288.6139 #&gt; TCGA-2J-AABV-01A-12R-A41B-07 TCGA-2J-AABE-01A-12R-A41B-07 #&gt; 826.7717 1336.8275 4.1.2 Clinical data To access the clinical data we can use the colData() function: colData(paad)[1:5, 1:5] #&gt; DataFrame with 5 rows and 5 columns #&gt; sample patient #&gt; &lt;character&gt; &lt;character&gt; #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 TCGA-3A-A9I7-01A TCGA-3A-A9I7 #&gt; TCGA-IB-7885-01A-11R-2156-07 TCGA-IB-7885-01A TCGA-IB-7885 #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 TCGA-2J-AAB1-01A TCGA-2J-AAB1 #&gt; TCGA-2L-AAQJ-01A-12R-A39D-07 TCGA-2L-AAQJ-01A TCGA-2L-AAQJ #&gt; TCGA-2J-AABV-01A-12R-A41B-07 TCGA-2J-AABV-01A TCGA-2J-AABV #&gt; barcode shortLetterCode #&gt; &lt;character&gt; &lt;character&gt; #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 TCGA-3A-A9I7-01A-21R-A38C-07 TP #&gt; TCGA-IB-7885-01A-11R-2156-07 TCGA-IB-7885-01A-11R-2156-07 TP #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 TCGA-2J-AAB1-01A-11R-A41B-07 TP #&gt; TCGA-2L-AAQJ-01A-12R-A39D-07 TCGA-2L-AAQJ-01A-12R-A39D-07 TP #&gt; TCGA-2J-AABV-01A-12R-A41B-07 TCGA-2J-AABV-01A-12R-A41B-07 TP #&gt; definition #&gt; &lt;character&gt; #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 Primary solid Tumor #&gt; TCGA-IB-7885-01A-11R-2156-07 Primary solid Tumor #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 Primary solid Tumor #&gt; TCGA-2L-AAQJ-01A-12R-A39D-07 Primary solid Tumor #&gt; TCGA-2J-AABV-01A-12R-A41B-07 Primary solid Tumor colnames(colData(paad))[1:20] #&gt; [1] &quot;sample&quot; &quot;patient&quot; #&gt; [3] &quot;barcode&quot; &quot;shortLetterCode&quot; #&gt; [5] &quot;definition&quot; &quot;synchronous_malignancy&quot; #&gt; ... #&gt; [15] &quot;primary_diagnosis&quot; &quot;age_at_diagnosis&quot; #&gt; [17] &quot;updated_datetime.x&quot; &quot;prior_malignancy&quot; #&gt; [19] &quot;year_of_diagnosis&quot; &quot;prior_treatment&quot; 4.1.3 PDAC Subtypes We are interested in obtaining Subtype specific information. The paad object comprises Subtype information for the Collisson, Moffitt and Bailey Classification schemes under the following columns: colnames(colData(paad))[grep(&quot;subtype_mRNA&quot;, colnames(colData(paad)))] #&gt; [1] &quot;subtype_mRNA.Moffitt.clusters..76.High.Purity.Samples.Only...1basal..2classical&quot; #&gt; [2] &quot;subtype_mRNA.Moffitt.clusters..All.150.Samples..1basal..2classical&quot; #&gt; [3] &quot;subtype_mRNA.Collisson.clusters..All.150.Samples..1classical.2exocrine.3QM&quot; #&gt; [4] &quot;subtype_mRNA.Bailey.Clusters..All.150.Samples..1squamous.2immunogenic.3progenitor.4ADEX&quot; Let’s extract the subtype information for the Moffitt classification scheme: subtype &lt;- colData(paad)[,&quot;subtype_mRNA.Moffitt.clusters..All.150.Samples..1basal..2classical&quot;] subtype #&gt; [1] 2 1 2 2 2 1 2 2 2 1 1 2 2 2 1 1 1 1 1 2 NA NA 2 2 #&gt; [25] 2 NA 2 1 2 1 1 2 2 1 NA 1 1 2 1 1 NA 1 2 2 1 1 2 2 #&gt; [49] NA 1 1 1 2 NA 2 2 2 NA 2 NA 2 1 1 NA 1 2 2 1 2 2 1 1 #&gt; [73] 1 2 2 2 2 NA 1 2 2 1 2 2 NA 1 2 2 2 NA 2 2 1 2 NA 2 #&gt; [97] 1 2 1 2 1 1 2 NA NA 2 1 1 2 1 2 1 NA 1 2 NA 2 1 2 NA #&gt; [121] 1 2 2 1 2 2 1 2 2 NA 2 1 1 2 NA 2 2 NA NA 1 NA 1 2 2 #&gt; [145] 1 NA 2 NA 2 1 2 2 1 1 2 2 NA 1 2 NA 1 2 1 NA 2 NA 2 NA #&gt; [169] 1 2 2 NA 1 2 1 2 NA 1 1 1 1 2 2 We want to compare the expression of a specific gene between the Classical and Basal samples. Looking at the subtype vector that we have just created there are multiple samples that do not have a Moffitt subtype - designated by NA. We need to remove these! expFinal &lt;- normalisedCounts[,!is.na(subtype)] subtypeFinal &lt;- subtype[!is.na(subtype)] subtypeFinal[subtypeFinal == 1] &lt;- &quot;Basal&quot; subtypeFinal[subtypeFinal == 2] &lt;- &quot;Classical&quot; subtypeFinal #&gt; [1] &quot;Classical&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; #&gt; [7] &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; &quot;Basal&quot; &quot;Classical&quot; #&gt; [13] &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; &quot;Basal&quot; &quot;Basal&quot; &quot;Basal&quot; #&gt; ... #&gt; [133] &quot;Basal&quot; &quot;Classical&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; #&gt; [139] &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Basal&quot; &quot;Classical&quot; #&gt; [145] &quot;Basal&quot; &quot;Basal&quot; &quot;Basal&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Classical&quot; 4.2 Descriptive plots 4.2.1 Boxplots A common task that we are asked to perform is: Determine whether a given gene is enriched in a specific PDAC subtype. How do we go about performing such a task and what sort of plots are useful in describing differences between groups? A popular method to display data involves drawing a box around the first and the third quartile (a bold line segment for the median), and the smaller line segments (whiskers) for the smallest and the largest data values. Such a data display is known as a box-and-whisker plot. expData &lt;- data.frame(samplename=colnames(expFinal), GATA6=expFinal[&quot;GATA6&quot;,], HNF4A=expFinal[&quot;HNF4A&quot;,], EGFR=expFinal[&quot;EGFR&quot;,], S100A2=expFinal[&quot;S100A2&quot;,], Subtype=subtypeFinal) head(expData) #&gt; samplename GATA6 #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 TCGA-3A-A9I7-01A-21R-A38C-07 628.0642 #&gt; TCGA-IB-7885-01A-11R-2156-07 TCGA-IB-7885-01A-11R-2156-07 742.8044 #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 TCGA-2J-AAB1-01A-11R-A41B-07 1664.3902 #&gt; TCGA-2L-AAQJ-01A-12R-A39D-07 TCGA-2L-AAQJ-01A-12R-A39D-07 1288.6139 #&gt; TCGA-2J-AABV-01A-12R-A41B-07 TCGA-2J-AABV-01A-12R-A41B-07 826.7717 #&gt; TCGA-2J-AABE-01A-12R-A41B-07 TCGA-2J-AABE-01A-12R-A41B-07 1336.8275 #&gt; HNF4A EGFR S100A2 Subtype #&gt; TCGA-3A-A9I7-01A-21R-A38C-07 2199.9155 515.8199 2453.9307 Classical #&gt; TCGA-IB-7885-01A-11R-2156-07 631.3670 1057.2997 1694.7218 Basal #&gt; TCGA-2J-AAB1-01A-11R-A41B-07 1254.1463 845.2976 136.0976 Classical #&gt; TCGA-2L-AAQJ-01A-12R-A39D-07 1263.8614 590.4901 209.4059 Classical #&gt; TCGA-2J-AABV-01A-12R-A41B-07 322.8346 157.4803 311.8110 Classical #&gt; TCGA-2J-AABE-01A-12R-A41B-07 581.4706 483.4161 125.7900 Basal To generate boxplots we will use the ggpubr package of plotting functions, which make generating publication quality plots simple. To generate a boxplot demonstrating the difference in GATA6 gene expression between the Basal and Classical subtypes run the following code snippet: library(ggpubr) #&gt; Warning: package &#39;ggpubr&#39; was built under R version 3.6.2 #&gt; Warning: package &#39;ggplot2&#39; was built under R version 3.6.2 ggboxplot(expData, x = &quot;Subtype&quot;, y = &quot;GATA6&quot;, title = &quot;GATA6 Expression by Subtype&quot;, ylab = &quot;Expression&quot;, color = &quot;Subtype&quot;, palette = &quot;jco&quot;) Figure 4.1: GATA6 Boxplot generated using ggboxplot coloured by Subtype We can also generate plots showing the relative expression of multiple genes. Here we combine boxplots for both the GATA6 and HNF4A genes. ggboxplot(expData, x = &quot;Subtype&quot;, y = c(&quot;GATA6&quot;,&quot;HNF4A&quot;), title = &quot;Expression by Subtype&quot;, combine = TRUE, ylab = &quot;Expression&quot;, color = &quot;Subtype&quot;, palette = &quot;jco&quot;) Figure 4.2: Combined Boxplot generated using ggboxplot coloured by Subtype The plotting function gghistogram can be used to generate a density histogram of the gene expression values for GATA6 and HNF4A. gghistogram(expData, x = c(&quot;GATA6&quot;,&quot;HNF4A&quot;), y = &quot;..density..&quot;, combine = TRUE, # Combine the 3 plots xlab = &quot;Expression&quot;, add = &quot;median&quot;, # Add median line. rug = TRUE, # Add marginal rug color = &quot;Subtype&quot;, fill = &quot;Subtype&quot;, palette = &quot;jco&quot; ) #&gt; Warning: Using `bins = 30` by default. Pick better value with the argument #&gt; `bins`. Figure 4.3: Combined density histogram generated using gghistogram coloured by Subtype To determine the statistical significance of the equality of the distributions we can take advantage of the stat_compare_means function. First we provide a vector of subtype names that we wish to compare - see my_comparisons variable. my_comparisons &lt;- list(c(&quot;Basal&quot;, &quot;Classical&quot;)) ggboxplot(expData, x = &quot;Subtype&quot;, y = c(&quot;GATA6&quot;,&quot;HNF4A&quot;), title = &quot;Expression by Subtype&quot;, combine = TRUE, ylab = &quot;Expression&quot;, color = &quot;Subtype&quot;, palette = &quot;jco&quot;) + stat_compare_means(comparisons = my_comparisons,) Figure 4.4: Combined Boxplot showing significance generated using ggboxplot and stat_compare_means coloured by Subtype What statistical test is being performed? To find a detailed summary of the statistical tests performed, we can use the compare_means function. compare_means(GATA6 ~ Subtype, data=expData) #&gt; # A tibble: 1 x 8 #&gt; .y. group1 group2 p p.adj p.format p.signif method #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 GATA6 Basal Classical 0.00000000424 0.0000000042 4.2e-09 **** Wilcox… Exercise 4.1 Repeat the above analysis using the Bailey classification scheme. How do the classification schemes differ? 4.2.2 Scatter plots Another common task is to determine the relationship or correlation between the expression of 2 genes. A scatter plot, where expression values for individual genes are positioned along the x and y axes, can be an effective means of describing the correlation between genes. In the following example we will look at genes having positive and negative correlation with GATA6 using the ggscatter function. We will also add the statistical significance of the correlation using the stat_cor function and include the regression line and confidence interval. First let’s identify genes that are positively and negatively correlated with GATA6. #Calculate the spearman correlation corGenes &lt;- apply(expFinal, 1, function(i){ cor(expFinal[&quot;GATA6&quot;,],i, method = &quot;spearman&quot;) }) #Identify top negatively correlated genes head(corGenes[order(corGenes)]) #&gt; ADAM19 BICD2 ARSI CHST11 PTPN1 PYGL #&gt; -0.5897631 -0.5516601 -0.5438659 -0.5425646 -0.5338886 -0.5319081 #Identify top positively correlated genes head(corGenes[order(corGenes, decreasing = TRUE)]) #&gt; GATA6 C9orf152 COLCA2 FMO5 COLCA1 HSD17B2 #&gt; 1.0000000 0.6421103 0.6379999 0.6319445 0.6310378 0.6218854 corData &lt;- data.frame(samplename=colnames(expFinal), GATA6=expFinal[&quot;GATA6&quot;,], ADAM19=expFinal[&quot;ADAM19&quot;,], C9orf152=expFinal[&quot;C9orf152&quot;,], Subtype=subtypeFinal) Now produce a scatter plot showing the correlation for a negatively correlated gene. ggscatter(corData, x = &quot;GATA6&quot;, y = &quot;ADAM19&quot;, size = 0.6, rug = TRUE, # Add marginal rug add = &quot;reg.line&quot;, conf.int = TRUE) + stat_cor(method = &quot;spearman&quot;) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Figure 4.5: Correlation bewteen the expression of GATA6 and ADAM19 using ggscatter and stat_cor coloured by Subtype Now produce a scatter plot showing the correlation for a positively correlated gene. ggscatter(corData, x = &quot;GATA6&quot;, y = &quot;C9orf152&quot;, size = 0.6, rug = TRUE, # Add marginal rug add = &quot;reg.line&quot;, conf.int = TRUE) + stat_cor(method = &quot;spearman&quot;) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Figure 4.6: Correlation bewteen the expression of GATA6 and C9orf152 using ggscatter and stat_cor coloured by Subtype Exercise 4.2 Are these genes significantly associated with the Classical or Basal subtype? Refering to Figure 4.7, select genes that either cluster together or separately and generate a correlation plot as above. 4.2.3 Hierarchical Clustering Clustering is a common analysis performed for gene expression data. The most often performed clustering method is hierarchical clustering, which typically takes the form of a heatmap. We will first compute the Pearson correlation between the genes. Note that we must operate on the transpose of the matrix because the R function cor() operates on the columns. Before computing the Pearson correlation let’s reduce the size of our gene expression matrix to the 100 most variable genes. # First create a helper function rnaSelectTopVarGenes &lt;- function(normCounts, n=2000){ mad &lt;- apply(normCounts, 1, mad) ords &lt;- names(sort(mad, decreasing=TRUE)) select &lt;- normCounts[ords[1:n],] select } top100 &lt;- rnaSelectTopVarGenes(expFinal, n=100) rownames(top100)[1:20] #&gt; [1] &quot;COL1A1&quot; &quot;COL3A1&quot; &quot;COL1A2&quot; &quot;FN1&quot; &quot;S100A6&quot; &quot;SPARC&quot; &quot;ACTG1&quot; #&gt; [8] &quot;ADAM6&quot; &quot;OLFM4&quot; &quot;KRT19&quot; &quot;FTL&quot; &quot;CEACAM6&quot; &quot;EEF1A1&quot; &quot;KRT8&quot; #&gt; [15] &quot;LYZ&quot; &quot;CD74&quot; &quot;C3&quot; &quot;ACTG1&quot; &quot;INS&quot; &quot;GAPDH&quot; Now we can compute the Pearson correlation between these genes. genes.cor &lt;- cor(t(top100), use=&quot;pairwise.complete.obs&quot;, method=&quot;pearson&quot;) genes.cor[1:10,1:10] #&gt; COL1A1 COL3A1 COL1A2 FN1 S100A6 #&gt; COL1A1 1.00000000 0.90111805 0.95213503 0.704581917 -0.03986419 #&gt; COL3A1 0.90111805 1.00000000 0.97895658 0.810404331 -0.17087257 #&gt; COL1A2 0.95213503 0.97895658 1.00000000 0.810587796 -0.09929872 #&gt; ADAM6 0.06159559 0.09015272 0.07347763 -0.006385034 -0.26308892 #&gt; OLFM4 -0.11225845 -0.15559795 -0.14019860 -0.157354325 0.11383937 #&gt; KRT19 -0.08529548 -0.20568537 -0.13710624 -0.057904466 0.59689349 #&gt; SPARC ACTG1 ADAM6 OLFM4 KRT19 #&gt; COL1A1 0.8537446 0.38503182 0.06159559 -0.11225845 -0.08529548 #&gt; COL3A1 0.9310155 0.25595807 0.09015272 -0.15559795 -0.20568537 #&gt; COL1A2 0.9331879 0.32340518 0.07347763 -0.14019860 -0.13710624 #&gt; ...&lt;4 more rows&gt;... #&gt; ADAM6 0.1679487 -0.04011457 1.00000000 -0.08934060 -0.26114447 #&gt; OLFM4 -0.1692385 0.01464192 -0.08934060 1.00000000 0.00350131 #&gt; KRT19 -0.2371568 0.41379145 -0.26114447 0.00350131 1.00000000 The Pearson correlation coefficient is a similarity metric, values of which vary from -1 (perfect anti-correlation) to +1 (perfect correlation), see Lectures Chap.1. Pearson’s correlation can be transformed into a distance metric by subtracting from 1. The Pearson distance would then vary from 0 (perfect correlation) to 2 (perfect anti-correlation). Hierarchical clustering of the Pearson distance metric can be achieved by the hclust() function. We will use the average linkage as an agglomeration rule. genes.cor.dist &lt;- as.dist(1-genes.cor) genes.tree &lt;- hclust(genes.cor.dist, method=&#39;average&#39;) plot(genes.tree, xlab=NULL, cex=0.5) Figure 4.7: Gene clustering by Pearson distance and average linkage Exercise 4.3 What do you observe? Does the clustering make any sense? A question that we might ask is whether the top 100 variable genes can discriminate Classical and Basal subtypes? We can answer this question by performing hierarchical clustering. To make our results a little easier to interpret let’s modify our top100 matrix by switching the column names to the PDAC subtype designations. colnames(top100) &lt;- subtypeFinal colnames(top100)[1:10] #&gt; [1] &quot;Classical&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; #&gt; [7] &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Basal&quot; Next let’s compute correlations between samples by using the Spearman rank as the metric. samples.cor.spearman &lt;- cor(top100,use=&quot;pairwise.complete.obs&quot;, method=&quot;spearman&quot;) samples.cor.spearman.dist &lt;- as.dist(1-samples.cor.spearman) samples.tree &lt;- hclust(samples.cor.spearman.dist, method=&#39;average&#39;) plot(samples.tree, cex=0.5, xlab=NULL) Figure 4.8: Sample clustering by Spearman distance and average linkage Exercise 4.4 What do you observe? Are the top 100 variables good at descriminating Classical from Basal samples? Would increasing the number of variable genes to 1000 help? What other agglomeration methods may be used with the hclust method? 4.2.4 Hierarchical clustering using the Moffitt transcriptomic signature Based on our previous clustering analysis, the top 100 most variable genes were not very good at discriminating the Classical and Basal samples. Let’s now use the genes that make up the Moffitt signature - this should allow us to classify the samples correctly! First we subset the expFinal matrix using the Moffitt classifier genes. mSig &lt;- read.csv(&quot;course/Moffitt_gene_signature.csv&quot;, stringsAsFactors = FALSE) head(mSig) #&gt; symbol Group #&gt; 1 MUC13 Classical #&gt; 2 GPR35 Classical #&gt; 3 USH1C Classical #&gt; 4 BAIAP2L2 Classical #&gt; 5 GAL3ST1 Classical #&gt; 6 VIL1 Classical dim(mSig) #&gt; [1] 88 2 expFinalSig &lt;- expFinal[rownames(expFinal) %in% mSig$symbol,] dim(expFinal) #&gt; [1] 19947 150 dim(expFinalSig) #&gt; [1] 86 150 Let’s now compute correlations between samples by using the Spearman rank as the metric, as before! #Set column names to Subtypes colnames(expFinalSig) &lt;- subtypeFinal #Perform clustering samples.cor.spearman &lt;- cor(expFinalSig,use=&quot;pairwise.complete.obs&quot;, method=&quot;spearman&quot;) samples.cor.spearman.dist &lt;- as.dist(1-samples.cor.spearman) samples.tree &lt;- hclust(samples.cor.spearman.dist, method=&#39;average&#39;) plot(samples.tree, cex=0.5, xlab=NULL) Figure 4.9: Sample clustering by Spearman distance and average linkage using Moffitt gene signature Exercise 4.5 What do you observe? Can we now descriminate Classical from Basal patient samples? 4.2.5 Heatmaps Hierarchical clustering methods enable hierarchical representations of a measure of dissimilarity between groups of observations (i.e. groups of genes and groups of patients in our PAAD example). The measure of dissimilarity is based on pairwise dissimilarities among the observations in the two groups. In the context of microarray or RNAseq data, a heatmap arranges both the rows and the columns of the expression matrix in orderings derived from hierarchical clustering. By cutting the dendrograms at various heights, different number of clusters emerge and the set of clusters are nested within one another. For our first example we will use the expFinalSig matrix representing genes defining the Moffitt classification scheme. The ComplexHeatmap and circlize packages will do the majority of the work! In this example we will generate an annotation track above the heatmap to show which samples are Classical and which are Basal. library(ComplexHeatmap) library(circlize) #&gt; Warning: package &#39;circlize&#39; was built under R version 3.6.2 #First we scale the matrix expFinalSig &lt;- t(scale(t(expFinalSig))) #Generate a list of colours to map to the Subtypes colors &lt;- RColorBrewer::brewer.pal(8, &quot;Set1&quot;) #Generate the annotation ha &lt;- HeatmapAnnotation(Moffitt = subtypeFinal, col = list(Moffitt = structure(names = c( &quot;Classical&quot;, &quot;Basal&quot; ), colors[1:2]))) #Generate the heatmap Heatmap( expFinalSig, col = colorRamp2(c(-2, 0, 2), c(&quot;#377EB8&quot;, &quot;white&quot;, &quot;#E41A1C&quot;)), name = &quot;Z score&quot;, cluster_columns = TRUE, cluster_rows = TRUE, top_annotation = ha, show_row_names = TRUE, show_column_names = TRUE, row_names_gp = gpar(fontsize = 8), column_names_gp = gpar(fontsize = 5) ) Figure 4.10: Heatmap using Moffitt gene signature We seem to be getting a good separation of the samples but it would be nice to have all of the Classical and Basal samples grouped together. Let’s first sort the subtypeFinal vector and columns of the expFinalSig matrix into their respective subtypes and regenerate the heatmap. head(order(subtypeFinal, decreasing = TRUE)) #&gt; [1] 1 3 4 5 7 8 subOrdered &lt;- subtypeFinal[order(subtypeFinal, decreasing = TRUE)] expFinalSigOrd &lt;- expFinalSig[, order(subtypeFinal, decreasing = TRUE)] #Make the sample annotation track ha &lt;- HeatmapAnnotation(Moffitt = subOrdered, col = list(Moffitt = structure(names = c( &quot;Classical&quot;, &quot;Basal&quot; ), colors[1:2]))) #Generate the heatmap Heatmap( expFinalSigOrd , col = colorRamp2(c(-2, 0, 2), c(&quot;#377EB8&quot;, &quot;white&quot;, &quot;#E41A1C&quot;)), name = &quot;Z score&quot;, cluster_columns = FALSE, #Turned clustering of columns off!!! cluster_rows = TRUE, top_annotation = ha, show_row_names = TRUE, show_column_names = TRUE, row_names_gp = gpar(fontsize = 8), column_names_gp = gpar(fontsize = 5) ) Figure 4.11: Heatmap using Moffitt gene signature ordered by subtype Let’s also annotate genes that discriminate the subtypes. To do this we will use the Heatmap split argument. #Map matrix gene names to subtype partition &lt;- rep(NA, nrow(expFinalSig)) partition[rownames(expFinalSig) %in% mSig$symbol[mSig$Group == &quot;Basal-like&quot;]] &lt;- &quot;Basal&quot; partition[rownames(expFinalSig) %in% mSig$symbol[mSig$Group == &quot;Classical&quot;]] &lt;- &quot;Classical&quot; head(partition) #&gt; [1] &quot;Basal&quot; &quot;Basal&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; &quot;Classical&quot; #Make the sample annotation track ha &lt;- HeatmapAnnotation(Moffitt = subOrdered, col = list(Moffitt = structure(names = c( &quot;Classical&quot;, &quot;Basal&quot; ), colors[1:2]))) #Generate the heatmap Heatmap( expFinalSigOrd , col = colorRamp2(c(-2, 0, 2), c(&quot;#377EB8&quot;, &quot;white&quot;, &quot;#E41A1C&quot;)), name = &quot;Z score&quot;, cluster_columns = FALSE, #Turned clustering of columns off!!! cluster_rows = TRUE, top_annotation = ha, split=partition, #added a partition argument show_row_names = TRUE, show_column_names = TRUE, row_names_gp = gpar(fontsize = 8), column_names_gp = gpar(fontsize = 5) ) Figure 4.12: Heatmap using Moffitt gene signature ordered by subtype and with gene annotations Exercise 4.6 Add the Collisson and Bailey subtype designations to the Heatmap annotation track! How do they compare? "],["rnaseq-analysis.html", "Chapter 5 RNAseq Analysis 5.1 RNAseq downstream analysis 5.2 Running the nf-core/rnaseq pipeline 5.3 Running the nf-core/rnaseq pipeline 5.4 Quality Control (QC) and Merged count files", " Chapter 5 RNAseq Analysis RNAseq (RNA-sequencing) is a technique that can examine the quantity and sequences of RNA in a sample using next generation sequencing (NGS). It analyzes the transcriptome of gene expression patterns encoded within our RNA. The following course provides an excellent overview of Next Generation Sequencing (NGS) and Illumina NGS Sample Preparation. Please take the time to watch the videos! Next Generation Sequencing 1 - Overview Next Generation Sequencing 2 - Sample Preparation In this talk, Eric Chow explains the chemistry behind next generation sequencing, and describes how the next gen sequencers detect and display results. The most commonly used Illumina sequencers are image based and detect the addition of fluorescently labelled nucleotides. Chow also describes two different next generation sequencing technologies which provide benefits such as much longer reads but with downsides such as higher error rates. Chow finishes the talk with some insights into medical applications of next gen sequencing such as much less invasive prenatal testing or cancer detection. In his second talk, Chow discusses Illumina NGS Sample Preparation. He goes over DNA and RNA preparation, bead-based (Ampure or SPRI) cleanups, and sample quantification and quality control. — https://www.ibiology.org/techniques/next-generation-sequencing/ 5.1 RNAseq downstream analysis 5.1.1 nf-core/rnaseq pipeline - installation nf-core/rnaseq is a bioinformatics analysis pipeline used for RNA sequencing data. The pipeline is built using Nextflow, a workflow tool to run tasks across multiple compute infrastructures in a portable manner. Detailed documentation on how to install and run nextflow and nf-core bioinformatic pipelines can be found at the following sites: https://nextflow.io/ https://nf-co.re/ For your convenience install instructions are reproduced below. 5.1.2 Nextflow All nf-core pipelines use Nextflow, so this must be present on the system where you launch your analysis. See nextflow.io for the latest installation instructions. Nextflow runs on most POSIX systems (Linux, Mac OSX etc) and can typically be installed by running the following commands: # Make sure that Java v8+ is installed: java -version # Install Nextflow curl -fsSL get.nextflow.io | bash # Add Nextflow binary to your user&#39;s PATH: mv nextflow ~/bin/ # OR system-wide installation: # sudo mv nextflow /usr/local/bin You can also install Nextflow using Bioconda: conda install -c bioconda nextflow 5.1.3 Additional pipeline software nf-core pipelines utilise Docker, Singularity and Conda to seamlessly install and run different software packages. These packages create isolated compute environments on the fly allowing for flexibility in development and delivery. Docker | Typically used locally / on single-user servers and the cloud. Analysis runs in a container, which behaves like an isolated operating system Previously required system root access, though a “rootless mode” is available since late 2019 Singularity | Often used as an alternative to Docker on multi-user systems such as HPC systems. Also runs containers and can create these from Docker images Does not need root access or any daemon processes - images built from files Conda | Packaging system that manages environments instead of running analysis in containers. Poorer reproducibility than Docker / Singularity There can be changes in low-level package dependencies over time The software still runs in your native operating system environment and so core system functions can differ 5.1.4 Pipeline code The nf-core pipeline does not need to be installed. On calling nextflow nf-core/rnaseq ..., pipeline components are automatically downloaded from github. 5.1.5 Reference genomes Some pipelines come with built-in support for iGenomes references. It may be preferable for you to download a local copy of these to your system so as to avoid fetching the same reference many times. For more information, see Reference genomes. 5.2 Running the nf-core/rnaseq pipeline Running the nf-core/rnaseq pipeline is incredibly simple and requires only a basic setup. 5.2.1 Setup The nf-core/rnaseq pipeline typically requires a sample sheet as input. The sample sheet should comprise the following columns. Column Description group Group identifier for sample. This will be identical for replicate samples from the same experimental group. replicate Integer representing replicate number. Must start from 1... fastq_1 Full path to FastQ file for read 1. File has to be zipped and have the extension “.fastq.gz” or “.fq.gz.” fastq_2 Full path to FastQ file for read 2. File has to be zipped and have the extension “.fastq.gz” or “.fq.gz.” strandedness Sample strand-specificity. Must be one of unstranded, forward or reverse. A final design file consisting of paired-end data may look something like the one below - see Table 3.1. This sample sheet represents a full sized RNAseq dataset obtained from the ENCODE project, which is routinely used to test the nf-core/rnaseq pipeline and is described here sampleSheet &lt;- read.delim(&quot;RNASeqData/samplesheet.valid.csv&quot;, stringsAsFactors = FALSE, sep = &quot;,&quot;) head(sampleSheet) #&gt; sample single_end #&gt; 1 GM12878_R1_T1 0 #&gt; 2 GM12878_R2_T1 0 #&gt; 3 H1_R1_T1 0 #&gt; 4 H1_R2_T1 0 #&gt; 5 K562_R1_T1 0 #&gt; 6 K562_R2_T1 0 #&gt; fastq_1 #&gt; 1 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603629_T1_1.fastq.gz #&gt; 2 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603630_T1_1.fastq.gz #&gt; 3 s3://nf-core-awsmegatests/rnaseq/input_data/SRX2370468_T1_1.fastq.gz #&gt; 4 s3://nf-core-awsmegatests/rnaseq/input_data/SRX2370469_T1_1.fastq.gz #&gt; 5 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603392_T1_1.fastq.gz #&gt; 6 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603393_T1_1.fastq.gz #&gt; fastq_2 #&gt; 1 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603629_T1_2.fastq.gz #&gt; 2 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603630_T1_2.fastq.gz #&gt; 3 s3://nf-core-awsmegatests/rnaseq/input_data/SRX2370468_T1_2.fastq.gz #&gt; 4 s3://nf-core-awsmegatests/rnaseq/input_data/SRX2370469_T1_2.fastq.gz #&gt; 5 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603392_T1_2.fastq.gz #&gt; 6 s3://nf-core-awsmegatests/rnaseq/input_data/SRX1603393_T1_2.fastq.gz #&gt; strandedness #&gt; 1 reverse #&gt; 2 reverse #&gt; 3 reverse #&gt; 4 reverse #&gt; 5 reverse #&gt; 6 reverse 5.3 Running the nf-core/rnaseq pipeline Once the setup is complete, running the nf-core/rnaseq pipeline is as simple as typing the following into the command line: nextflow run nf-core/rnaseq \\ --input samplesheet.csv \\ --fasta &#39;&lt;PATH TO FASTA FILE&gt;/genome.fa&#39;\\ --gtf &#39;&lt;PATH TO FASTA FILE&gt;/genome.gtf&#39; --aligner star_rsem -profile conda 5.4 Quality Control (QC) and Merged count files After run completion, the nf-core pipeline will generate a number of data files that can be used to assess sequence quality and for downstream analysis. A typical run folder will comprise the following folder structure. Please see Run Folder Example. 5.4.1 QC Metrics The first step after the completion of any analysis run is to check the QC metrics. A summary of all QC metrics for a given run can be found in the file named multiqc_report.html, which is located in the MultiQC folder. A detailed overview of the content provided in the MultiQC report can be found at the following location https://nf-co.re/rnaseq/3.0/output 5.4.2 Merged count files After assessing QC, we are ready to start a primary analysis of the data. To do so we will typically use a merged gene count file. For example, rsem.merged.gene_counts.tsv. These files typically comprise the Ensembl Gene ID, Ensembl Transcript ID and Sample IDs with each column/row entry representing the read count for a given gene. See example below: mergedCounts &lt;- read.delim(&quot;RNASeqData/rsem.merged.gene_counts.tsv&quot;, stringsAsFactors = FALSE, sep = &quot;\\t&quot;) colnames(mergedCounts) #&gt; [1] &quot;gene_id&quot; &quot;transcript_id.s.&quot; &quot;GM12878_R1&quot; #&gt; [4] &quot;GM12878_R2&quot; &quot;H1_R1&quot; &quot;H1_R2&quot; #&gt; [7] &quot;K562_R1&quot; &quot;K562_R2&quot; &quot;MCF7_R1&quot; #&gt; [10] &quot;MCF7_R2&quot; mergedCounts[1:5,c(1,3:7)] #&gt; gene_id GM12878_R1 GM12878_R2 H1_R1 H1_R2 K562_R1 #&gt; 1 ENSG00000000003 7 0 8299 4390 3 #&gt; 2 ENSG00000000005 0 0 69 30 0 #&gt; 3 ENSG00000000419 4061 3582 1885 796 6194 #&gt; 4 ENSG00000000457 1942 1606 592 409 918 #&gt; 5 ENSG00000000460 1862 1612 3594 1748 2813 "],["rnaseq-analysis-deseq2.html", "Chapter 6 RNAseq Analysis - DESeq2 6.1 DESEq2 package 6.2 The DESeqDataSet 6.3 Count matrix input 6.4 Pre-filtering 6.5 Differential expression analysis 6.6 Gene Annotation 6.7 Exploring the results 6.8 Exporting results 6.9 Data transformation and visualisation 6.10 Gene Set Enrichment Analysis", " Chapter 6 RNAseq Analysis - DESeq2 In this Chapter, we will be analyzing RNAseq data previously published in Brunton et al. HNF4A and GATA6 Loss Reveals Therapeutically Actionable Subtypes in Pancreatic Cancer. Cell Reports 2020. The RNAseq experiment that we will re-analyse involves the Knock-Down (KD) of HNF4A using a specific siRNA in 2 different Patient Derived Cell Lines (PDCLs) Mayo5289 and TKCC22. Both Mayo5289 and TKCC22 are Classical lines which expresses HNF4A. We have 12 samples in total, representing: 3x Mayo5289 Scrambled Controls (Biological Replicates) 3x Mayo5289 siHNF4A (Biological Replicates) 3x TKCC22 Scrambled Controls (Biological Replicates) 3x TKCC22 siHNF4A (Biological Replicates) RNAseq data has been mapped and a merged counts file is available for us to analyse. Let’s take a look at the sample sheet for the experiment. sampleSheet &lt;- read.delim(&quot;RNASeqData/SampleSheetBrunton.tsv&quot;, sep = &quot;\\t&quot;, stringsAsFactors = FALSE) sampleSheet #&gt; id Treatment_group Batch #&gt; 1 HB.A1 TKCC-22_Cont 1 #&gt; 2 HB.A3 TKCC-22_HNF4A 1 #&gt; 3 HB.B1 TKCC-22_Cont 2 #&gt; ...&lt;6 more rows&gt;... #&gt; 10 HB.E3 Mayo_5289_HNF4A 2 #&gt; 11 HB.F1 Mayo_5289_Cont 3 #&gt; 12 HB.F3 Mayo_5289_HNF4A 3 The merged counts file is in the following format: countsFile &lt;- read.delim(&quot;RNASeqData/CountsFileBrunton.tsv&quot;, stringsAsFactors = FALSE, sep = &quot;\\t&quot;,row.names = 1) head(countsFile) #&gt; HB.A1 HB.A3 HB.B1 HB.B3 HB.C1 HB.C3 HB.D1 HB.D3 HB.E1 HB.E3 #&gt; ENSG00000223972 0 0 0 0 0 0 1 0 0 0 #&gt; ENSG00000227232 206 147 149 161 160 184 154 200 222 201 #&gt; ENSG00000243485 0 0 0 0 0 0 0 0 0 0 #&gt; ENSG00000237613 0 0 0 0 0 0 0 0 0 0 #&gt; ENSG00000268020 0 0 0 0 0 0 0 0 0 0 #&gt; ENSG00000240361 0 0 0 0 0 0 0 0 0 0 #&gt; HB.F1 HB.F3 #&gt; ENSG00000223972 0 0 #&gt; ENSG00000227232 167 188 #&gt; ENSG00000243485 0 0 #&gt; ENSG00000237613 0 0 #&gt; ENSG00000268020 0 0 #&gt; ENSG00000240361 0 0 6.1 DESEq2 package The DESeq2 package expects count data in the form of a matrix of integer values as input. The values in the matrix should be non-normalized counts or estimated counts of sequencing reads (for single-end RNA-seq) or fragments (for paired-end RNA-seq). The DESeq2 model internally corrects for library size, so transformed or normalized values such as counts scaled by library size should not be used as input. The DESeq2 package stores the read counts and the results of any analysis in an object of class DESeqDataSet. The DESeqDataSet class extends the RangedSummarizedExperiment class of the SummarizedExperiment package, which we used previously in Section 4.2. 6.2 The DESeqDataSet A DESeqDataSet object must have an associated design formula. The design formula expresses the variables which will be used in modeling. The formula should be a tilde (~) followed by the variables with plus signs between them (it will be coerced into an formula if it is not already). 6.3 Count matrix input The function DESeqDataSetFromMatrix can be used to generate a RangedSummarizedExperiment object comprising our data. The Treatment_group sample sheet column is used for our design formula! library(DESeq2) ## Produce a DESeq dataset dds &lt;- DESeqDataSetFromMatrix(countData = countsFile, colData = sampleSheet, design = ~ Treatment_group) #&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in #&gt; design formula are characters, converting to factors #&gt; Note: levels of factors in the design contain characters other than #&gt; letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use #&gt; only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters #&gt; for column names in R. [This is a message, not an warning or error] Let’s take a look at the colData for this object. The colData function will allow us to access the Treatment_group and experiment ids later on! head(colData(dds)) #&gt; DataFrame with 6 rows and 3 columns #&gt; id Treatment_group Batch #&gt; &lt;character&gt; &lt;factor&gt; &lt;integer&gt; #&gt; HB.A1 HB.A1 TKCC-22_Cont 1 #&gt; HB.A3 HB.A3 TKCC-22_HNF4A 1 #&gt; HB.B1 HB.B1 TKCC-22_Cont 2 #&gt; HB.B3 HB.B3 TKCC-22_HNF4A 2 #&gt; HB.C1 HB.C1 TKCC-22_Cont 3 #&gt; HB.C3 HB.C3 TKCC-22_HNF4A 3 6.4 Pre-filtering While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: - by removing rows in which there are very few reads, we reduce the memory size of the dds data object - we increase the speed of the transformation and testing functions within DESeq2. Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total. Note that more strict filtering to increase power is automatically applied via independent filtering on the mean of normalized counts within the results function. keep &lt;- rowSums(counts(dds)) &gt;= 10 dds &lt;- dds[keep,] 6.5 Differential expression analysis The standard differential expression analysis steps are wrapped into a single function named DESeq. Results tables are generated using the function results, which extracts a results table with log2 fold changes, p values and adjusted p values. Here we want to compare differential gene expression in the TKCC22 and Mayo5289 PDCLs, separately. To do this we can provide a contrast argument, where the first vector value is our design name and the other vector values represent the contrast of interest! dds &lt;- DESeq(dds) resTKCC22 &lt;- results(dds, contrast=c(&quot;Treatment_group&quot;, &quot;TKCC-22_HNF4A&quot;, &quot;TKCC-22_Cont&quot;)) head(resTKCC22) #&gt; log2 fold change (MLE): Treatment_group TKCC-22_HNF4A vs TKCC-22_Cont #&gt; Wald test p-value: Treatment_group TKCC-22_HNF4A vs TKCC-22_Cont #&gt; DataFrame with 6 rows and 6 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000227232 176.215965236868 0.0681688692461893 0.155683348871782 #&gt; ENSG00000238009 4.95585118508252 -1.27198412595543 0.897892011941174 #&gt; ENSG00000237683 23.0539253255181 -0.26031208423795 0.530153592513952 #&gt; ENSG00000241860 26.5900311689865 0.368471855396428 0.402842462674039 #&gt; ENSG00000228463 25.8307510095804 -0.144518497310896 0.356207690630831 #&gt; ENSG00000237094 1.06267800811557 1.70544281563047 2.03235686968038 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000227232 0.43786872353531 0.66148144925531 0.862931209585896 #&gt; ENSG00000238009 -1.41663374775492 0.156590036356189 NA #&gt; ENSG00000237683 -0.491012581851172 0.623417548715701 NA #&gt; ENSG00000241860 0.914679780653059 0.360359762037706 NA #&gt; ENSG00000228463 -0.405714141249896 0.684952650597028 NA #&gt; ENSG00000237094 0.839145349457587 0.401387750491202 NA resMayo5289 &lt;- results(dds, contrast=c(&quot;Treatment_group&quot;, &quot;Mayo_5289_HNF4A&quot;, &quot;Mayo_5289_Cont&quot;)) head(resMayo5289) #&gt; log2 fold change (MLE): Treatment_group Mayo_5289_HNF4A vs Mayo_5289_Cont #&gt; Wald test p-value: Treatment group Mayo 5289 HNF4A vs Mayo 5289 Cont #&gt; DataFrame with 6 rows and 6 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000227232 176.215965236868 -0.0119495009244944 0.15255273154876 #&gt; ENSG00000238009 4.95585118508252 -0.626000432390719 0.809896379944906 #&gt; ENSG00000237683 23.0539253255181 -0.206194554568681 0.419326773029208 #&gt; ENSG00000241860 26.5900311689865 0.0661684857011655 0.355511952662026 #&gt; ENSG00000228463 25.8307510095804 -0.234755143878033 0.323620257076077 #&gt; ENSG00000237094 1.06267800811557 -3.15503624670329 2.1465733495444 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000227232 -0.0783302980102654 0.937565317169935 0.970065078334923 #&gt; ENSG00000238009 -0.772938918968009 0.439558530357351 NA #&gt; ENSG00000237683 -0.49172761633877 0.622911912676688 0.794297567450887 #&gt; ENSG00000241860 0.186121690721521 0.852349332369706 0.931857984783944 #&gt; ENSG00000228463 -0.725403119072509 0.468204760148512 0.679428386866806 #&gt; ENSG00000237094 -1.46980127530836 0.141615583670199 NA The results are not ordered by p value so let’s order the results so that the most significant results are shown at the top of the table. resTKCC22.Ordered &lt;- resTKCC22[order(resTKCC22$pvalue),] head(resTKCC22.Ordered) #&gt; log2 fold change (MLE): Treatment_group TKCC-22_HNF4A vs TKCC-22_Cont #&gt; Wald test p-value: Treatment_group TKCC-22_HNF4A vs TKCC-22_Cont #&gt; DataFrame with 6 rows and 6 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000110092 47574.3163285699 -0.934451413369446 0.0663560063758533 #&gt; ENSG00000101076 2441.44886387565 -1.2534535054247 0.0897912061465399 #&gt; ENSG00000167460 13340.8304535922 0.848040750049125 0.0654138250456114 #&gt; ENSG00000197008 692.953231862017 1.15818733365479 0.0893877618088685 #&gt; ENSG00000112419 4645.27612423264 0.814829053165872 0.0655868735363201 #&gt; ENSG00000054983 3591.9079640758 -0.772496907696008 0.0657930175504959 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000110092 -14.0823938088819 4.87307090466001e-45 6.78623854182953e-41 #&gt; ENSG00000101076 -13.9596465981207 2.74793035252734e-44 1.91338390446479e-40 #&gt; ENSG00000167460 12.9642434066164 1.95146374859122e-38 7.47764079018454e-35 #&gt; ENSG00000197008 12.9568892901834 2.14782156834254e-38 7.47764079018454e-35 #&gt; ENSG00000112419 12.4236605471771 1.94456107359187e-35 5.41599150216807e-32 #&gt; ENSG00000054983 -11.7413205299957 7.82549268200408e-32 1.81629685149315e-28 resMayo5289.Ordered &lt;- resMayo5289[order(resMayo5289$pvalue),] head(resMayo5289.Ordered) #&gt; log2 fold change (MLE): Treatment_group Mayo_5289_HNF4A vs Mayo_5289_Cont #&gt; Wald test p-value: Treatment group Mayo 5289 HNF4A vs Mayo 5289 Cont #&gt; DataFrame with 6 rows and 6 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 2441.44886387565 -2.78867240452894 0.0928799664884088 #&gt; ENSG00000110092 47574.3163285699 -1.5069874076035 0.0661753371004424 #&gt; ENSG00000127831 5402.36212558166 -1.47536222408073 0.0721308861825415 #&gt; ENSG00000155465 1117.788063774 -1.6920701897444 0.0850231608539067 #&gt; ENSG00000101342 496.544981122766 -2.36158629500247 0.123882852836385 #&gt; ENSG00000101311 12900.2341316972 -1.03950771162206 0.0548227604532701 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 -30.0244768593554 4.7036205234925e-198 7.69653426259078e-194 #&gt; ENSG00000110092 -22.7726442151124 8.5621641757204e-115 7.00513462036565e-111 #&gt; ENSG00000127831 -20.453959491736 5.53914538617638e-93 3.02123453180014e-89 #&gt; ENSG00000155465 -19.901285399773 3.96625810089935e-88 1.6224970326254e-84 #&gt; ENSG00000101342 -19.0630603100614 5.11911428173576e-81 1.67528133984085e-77 #&gt; ENSG00000101311 -18.9612435241768 3.56612180336771e-80 9.72540851141765e-77 6.6 Gene Annotation To annotate gene names, we will use the AnnotationDbi and org.Hs.eg.db packages which provide functions to map ensembl Ids to HGNC symbol names. Other annotations are also provided which you can explore. library(&quot;AnnotationDbi&quot;) library(&quot;org.Hs.eg.db&quot;) columns(org.Hs.eg.db) #&gt; [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; #&gt; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; #&gt; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; #&gt; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; #&gt; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; #&gt; [21] &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; &quot;UCSCKG&quot; #&gt; [25] &quot;UNIGENE&quot; &quot;UNIPROT&quot; The following code maps the EnsemblIDs e.g. ENSG00000223972 to gene symbols and EntrezIds. First we obtain the vector of EnsemblIDs found in our resMayo5289.Ordered data.frame - EnsemblIDs represent the row names of the data.frame and can be obtained using the rownames() function. We then use the mapIds function to match each EnsemblID to a corresponding gene symbol and assign the results to a new column named symbol. #Extract the EnsemblIds ensIds &lt;- rownames(resMayo5289.Ordered) #Map the ensIds resMayo5289.Ordered$symbol &lt;- mapIds(org.Hs.eg.db, keys=ensIds, column=&quot;SYMBOL&quot;, keytype=&quot;ENSEMBL&quot;, multiVals=&quot;first&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns resMayo5289.Ordered$entrez &lt;- mapIds(org.Hs.eg.db, keys=ensIds, column=&quot;ENTREZID&quot;, keytype=&quot;ENSEMBL&quot;, multiVals=&quot;first&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns head(resMayo5289.Ordered) #&gt; log2 fold change (MLE): Treatment_group Mayo_5289_HNF4A vs Mayo_5289_Cont #&gt; Wald test p-value: Treatment group Mayo 5289 HNF4A vs Mayo 5289 Cont #&gt; DataFrame with 6 rows and 8 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 2441.44886387565 -2.78867240452894 0.0928799664884088 #&gt; ENSG00000110092 47574.3163285699 -1.5069874076035 0.0661753371004424 #&gt; ENSG00000127831 5402.36212558166 -1.47536222408073 0.0721308861825415 #&gt; ENSG00000155465 1117.788063774 -1.6920701897444 0.0850231608539067 #&gt; ENSG00000101342 496.544981122766 -2.36158629500247 0.123882852836385 #&gt; ENSG00000101311 12900.2341316972 -1.03950771162206 0.0548227604532701 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 -30.0244768593554 4.7036205234925e-198 7.69653426259078e-194 #&gt; ENSG00000110092 -22.7726442151124 8.5621641757204e-115 7.00513462036565e-111 #&gt; ENSG00000127831 -20.453959491736 5.53914538617638e-93 3.02123453180014e-89 #&gt; ENSG00000155465 -19.901285399773 3.96625810089935e-88 1.6224970326254e-84 #&gt; ENSG00000101342 -19.0630603100614 5.11911428173576e-81 1.67528133984085e-77 #&gt; ENSG00000101311 -18.9612435241768 3.56612180336771e-80 9.72540851141765e-77 #&gt; symbol entrez #&gt; &lt;character&gt; &lt;character&gt; #&gt; ENSG00000101076 HNF4A 3172 #&gt; ENSG00000110092 CCND1 595 #&gt; ENSG00000127831 VIL1 7429 #&gt; ENSG00000155465 SLC7A7 9056 #&gt; ENSG00000101342 TLDC2 140711 #&gt; ENSG00000101311 FERMT1 55612 resTKCC22.Ordered$symbol &lt;- mapIds(org.Hs.eg.db, keys=ensIds, column=&quot;SYMBOL&quot;, keytype=&quot;ENSEMBL&quot;, multiVals=&quot;first&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns resTKCC22.Ordered$entrez &lt;- mapIds(org.Hs.eg.db, keys=ensIds, column=&quot;ENTREZID&quot;, keytype=&quot;ENSEMBL&quot;, multiVals=&quot;first&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns Exercise 6.1 What do you think the multiVals argument in the mapIds function is doing? Add additional annotations to the resMayo5289.Ordered data.frame. 6.7 Exploring the results At this stage we often want to get a first glimpse of the results. Let’s first determine how many genes are differentially expressed in the Mayo5289 cells after KD with HNF4A! #How many genes change significantly between conditions? sum(resMayo5289.Ordered$pvalue &lt;= 0.05, na.rm=TRUE) #&gt; [1] 5594 sum(resMayo5289.Ordered$padj &lt;= 0.05, na.rm=TRUE) #&gt; [1] 3852 #How many are also associated with abs(log2FC) &gt;= 1 sum(resMayo5289.Ordered$padj &lt;=0.05 &amp; abs(resMayo5289.Ordered$log2FoldChange) &gt;= 1, na.rm=TRUE) #&gt; [1] 368 We might also like to get an idea about the top 10 genes ranked by padj and LogFC resMayo5289.Ordered &lt;- resMayo5289.Ordered[!is.na(resMayo5289.Ordered$padj), ] sigGenesMayo5289 &lt;- resMayo5289.Ordered[resMayo5289.Ordered$padj &lt;= 0.05 &amp; abs(resMayo5289.Ordered$log2FoldChange) &gt;= 1, ] head(sigGenesMayo5289,3) #&gt; log2 fold change (MLE): Treatment_group Mayo_5289_HNF4A vs Mayo_5289_Cont #&gt; Wald test p-value: Treatment group Mayo 5289 HNF4A vs Mayo 5289 Cont #&gt; DataFrame with 3 rows and 8 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 2441.44886387565 -2.78867240452894 0.0928799664884088 #&gt; ENSG00000110092 47574.3163285699 -1.5069874076035 0.0661753371004424 #&gt; ENSG00000127831 5402.36212558166 -1.47536222408073 0.0721308861825415 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000101076 -30.0244768593554 4.7036205234925e-198 7.69653426259078e-194 #&gt; ENSG00000110092 -22.7726442151124 8.5621641757204e-115 7.00513462036565e-111 #&gt; ENSG00000127831 -20.453959491736 5.53914538617638e-93 3.02123453180014e-89 #&gt; symbol entrez #&gt; &lt;character&gt; &lt;character&gt; #&gt; ENSG00000101076 HNF4A 3172 #&gt; ENSG00000110092 CCND1 595 #&gt; ENSG00000127831 VIL1 7429 sigGenesMayo5289$symbol[1:10] #&gt; ENSG00000101076 ENSG00000110092 ENSG00000127831 ENSG00000155465 #&gt; &quot;HNF4A&quot; &quot;CCND1&quot; &quot;VIL1&quot; &quot;SLC7A7&quot; #&gt; ENSG00000101342 ENSG00000101311 ENSG00000115641 ENSG00000058085 #&gt; &quot;TLDC2&quot; &quot;FERMT1&quot; &quot;FHL2&quot; &quot;LAMC2&quot; #&gt; ENSG00000186832 ENSG00000180745 #&gt; &quot;KRT16&quot; &quot;CLRN3&quot; Exercise 6.2 What do you observe? Do the genes at the top of our list make sense? We also might want to compare our HNF4A KD results in both the TKCC22 and Mayo5289 PDCLs? Upset plots are a nice way of comparing the relationship between data sets. The UpSetR package provides a simple set of functions to define data set overlap. library(UpSetR) library(ggplot2) #Set up the Mayo5289 gene list sigGenesMayo5289 &lt;- resMayo5289.Ordered[resMayo5289.Ordered$padj &lt;=0.05 &amp; abs(resMayo5289.Ordered$log2FoldChange) &gt;= 1, &quot;symbol&quot;] #Set up the TKCC22 gene list #Need to remove NAs as above resTKCC22.Ordered &lt;- resTKCC22.Ordered[!is.na(resTKCC22.Ordered$padj), ] sigGenesTKCC22 &lt;- resTKCC22.Ordered[resTKCC22.Ordered$padj &lt;=0.05 &amp; abs(resTKCC22.Ordered$log2FoldChange) &gt;= 1, &quot;symbol&quot;] #Create a list of genes listInput &lt;- list(TKCC22 = sigGenesTKCC22 , Mayo5289 = sigGenesMayo5289) #Create the plot upset(fromList(listInput), order.by = &quot;freq&quot;) Figure 6.1: UpSet plot showing the relationship between the TKCC22 and Mayo-5289 experiments Exercise 6.3 What are the genes in common? Hint: try the interesect function! 6.8 Exporting results Exporting results is straight forward! Results can also be stored in an .RData file for later use! write.csv(as.data.frame(resMayo5289.Ordered), file = &quot;resMayo5289.Ordered_results.csv&quot;) save(dds, resMayo5289.Ordered, resTKCC22.Ordered, file = &quot;PDCL_HNF4A_siRNA_Experiment.RData&quot;) 6.9 Data transformation and visualisation For downstream analyses – e.g. for visualization or clustering – we need to work with transformed versions of the count data. There are a number of methods to transform count data provided in the DESeq2 package and include variance stabilizing transformations (vst) and regularized logarithm (rlog). Both the vst and rlog transformations remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low. The vst and rlog transformations produce transformed data on the log2 scale which has been normalized with respect to library size and/or other normalization factors. The assay function returns the results of the transformation as a matrix of transformed values. vsd &lt;- vst(dds, blind=FALSE) rld &lt;- rlog(dds, blind=FALSE) head(assay(vsd), 3) #&gt; HB.A1 HB.A3 HB.B1 HB.B3 HB.C1 HB.C3 #&gt; ENSG00000227232 8.566844 8.611630 8.585389 8.633558 8.530630 8.541801 #&gt; ENSG00000238009 7.239080 7.321780 7.438567 7.012016 7.263053 7.178992 #&gt; ENSG00000237683 7.239080 7.351215 7.627718 7.414596 7.343795 7.402633 #&gt; HB.D1 HB.D3 HB.E1 HB.E3 HB.F1 HB.F3 #&gt; ENSG00000227232 8.688812 8.668386 8.761663 8.676995 8.490305 8.584954 #&gt; ENSG00000238009 7.330801 7.288113 7.341380 7.289009 7.349144 7.252707 #&gt; ENSG00000237683 7.833839 7.755957 7.742276 7.768123 7.794813 7.687399 6.9.1 PCA using transformed data A well-established technique for visualization and extraction of relevant information is the popular Principal Component Analysis (PCA). PCA allows us to determine the relationship between samples and can provide valuable insights into the veracity of the results. library(ggplot2) pcaData &lt;- plotPCA(vsd, intgroup=c(&quot;Treatment_group&quot;, &quot;Batch&quot;), returnData=TRUE) percentVar &lt;- round(100 * attr(pcaData, &quot;percentVar&quot;)) ggplot(pcaData, aes(PC1, PC2, color=Treatment_group, shape=as.factor(Batch))) + geom_point(size=3) + xlab(paste0(&quot;PC1: &quot;,percentVar[1],&quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;,percentVar[2],&quot;% variance&quot;)) Figure 6.2: Principal Component Analysis (PCA) plot showing the relationship between the TKCC22 and Mayo-5289 experiments 6.9.2 Heatmaps using transformed data Using vsd transformed data let’s generate a heatmap showing a selection of genes that are differentially expressed after HNF4A KD in the Mayo5289 cell line. #Looking at the vsd matrix it comprises EnsemblIds and not gene symbols as row names! head(assay(vsd), 3) #&gt; HB.A1 HB.A3 HB.B1 HB.B3 HB.C1 HB.C3 #&gt; ENSG00000227232 8.566844 8.611630 8.585389 8.633558 8.530630 8.541801 #&gt; ENSG00000238009 7.239080 7.321780 7.438567 7.012016 7.263053 7.178992 #&gt; ENSG00000237683 7.239080 7.351215 7.627718 7.414596 7.343795 7.402633 #&gt; HB.D1 HB.D3 HB.E1 HB.E3 HB.F1 HB.F3 #&gt; ENSG00000227232 8.688812 8.668386 8.761663 8.676995 8.490305 8.584954 #&gt; ENSG00000238009 7.330801 7.288113 7.341380 7.289009 7.349144 7.252707 #&gt; ENSG00000237683 7.833839 7.755957 7.742276 7.768123 7.794813 7.687399 expMatrix &lt;- assay(vsd) #To make the Heatmap we will select genes based on our significant cutoffs resMayo5289.Ordered &lt;- resMayo5289.Ordered[!is.na(resMayo5289.Ordered$symbol),] resMayo5289.select &lt;- subset(resMayo5289.Ordered, padj &lt;= 1e-20 &amp; abs(resMayo5289.Ordered$log2FoldChange) &gt;= 1) #Map the significant results to the transformed expression values inter &lt;- intersect(rownames(expMatrix), rownames(resMayo5289.select)) head(inter) #&gt; [1] &quot;ENSG00000162545&quot; &quot;ENSG00000137959&quot; &quot;ENSG00000198758&quot; &quot;ENSG00000134193&quot; #&gt; [5] &quot;ENSG00000198483&quot; &quot;ENSG00000163209&quot; #Subset the matrix to include only the significant genes of interest expMatrix.select &lt;- expMatrix[inter, ] dim(expMatrix.select) #&gt; [1] 82 12 head(expMatrix.select) #&gt; HB.A1 HB.A3 HB.B1 HB.B3 HB.C1 HB.C3 #&gt; ENSG00000162545 10.895563 10.600985 10.910440 10.657951 10.842195 10.633991 #&gt; ENSG00000137959 7.387884 7.580602 7.246242 7.513228 7.292596 7.467657 #&gt; ENSG00000198758 10.109697 9.496844 10.195344 9.511486 10.207478 9.498285 #&gt; ENSG00000134193 7.906800 7.876837 7.934171 7.830890 7.870031 7.882784 #&gt; ENSG00000198483 7.172658 7.289183 7.203331 7.280885 7.012016 7.216462 #&gt; ENSG00000163209 7.332804 7.378253 7.416824 7.280885 7.292596 7.130119 #&gt; HB.D1 HB.D3 HB.E1 HB.E3 HB.F1 HB.F3 #&gt; ENSG00000162545 11.092906 10.173745 11.041170 10.154572 11.05369 10.048354 #&gt; ENSG00000137959 10.489250 11.855465 10.855140 12.085880 10.74541 11.910030 #&gt; ENSG00000198758 11.218128 10.317309 11.248313 10.373998 11.20353 10.299625 #&gt; ENSG00000134193 11.622704 10.881198 11.747548 10.706791 11.75830 10.660777 #&gt; ENSG00000198483 8.229145 9.195484 8.268459 9.225827 8.18042 9.111117 #&gt; ENSG00000163209 10.769595 9.569257 10.669877 9.599853 10.55096 9.571898 Let’s now finish off the matrix by swapping the Ensembl IDs for the gene symbols - this will make our heatmap biologist friendly! We also want to limit the matrix to the Mayo5289 HNF4A KD experiment! #Add human readable gene names rownames(expMatrix.select) &lt;- mapIds(org.Hs.eg.db, keys=rownames(expMatrix.select), column=&quot;SYMBOL&quot;, keytype=&quot;ENSEMBL&quot;, multiVals=&quot;first&quot;) #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns head(rownames(expMatrix.select)) #&gt; ENSG00000162545 ENSG00000137959 ENSG00000198758 ENSG00000134193 #&gt; &quot;CAMK2N1&quot; &quot;IFI44L&quot; &quot;EPS8L3&quot; &quot;REG4&quot; #&gt; ENSG00000198483 ENSG00000163209 #&gt; &quot;ANKRD35&quot; &quot;SPRR3&quot; #Select the Mayo5289 columns expMatrix.select &lt;- expMatrix.select[, grepl(&quot;Mayo_5289_HNF4A|Mayo_5289_Cont&quot;,colData(dds)$Treatment_group)] #Give the matrix some useful column names colnames(expMatrix.select) &lt;- colData(dds)[colnames(expMatrix.select),&quot;Treatment_group&quot;] head(expMatrix.select) #&gt; Mayo_5289_Cont Mayo_5289_HNF4A Mayo_5289_Cont Mayo_5289_HNF4A #&gt; CAMK2N1 11.092906 10.173745 11.041170 10.154572 #&gt; IFI44L 10.489250 11.855465 10.855140 12.085880 #&gt; EPS8L3 11.218128 10.317309 11.248313 10.373998 #&gt; REG4 11.622704 10.881198 11.747548 10.706791 #&gt; ANKRD35 8.229145 9.195484 8.268459 9.225827 #&gt; SPRR3 10.769595 9.569257 10.669877 9.599853 #&gt; Mayo_5289_Cont Mayo_5289_HNF4A #&gt; CAMK2N1 11.05369 10.048354 #&gt; IFI44L 10.74541 11.910030 #&gt; EPS8L3 11.20353 10.299625 #&gt; REG4 11.75830 10.660777 #&gt; ANKRD35 8.18042 9.111117 #&gt; SPRR3 10.55096 9.571898 We now make the heatmap using the ComplexHeatmap package. library(ComplexHeatmap) library(circlize) #Define some colours for the annotation colors &lt;- RColorBrewer::brewer.pal(8, &quot;Set1&quot;) #Make the sample annotation track ha &lt;- HeatmapAnnotation(Treatment = colnames(expMatrix.select), col = list(Treatment = structure(names = c( &quot;Mayo_5289_Cont&quot;, &quot;Mayo_5289_HNF4A&quot; ), colors[3:4]))) #Scale the matrix to generate z-scores expMatrix.select.sc &lt;- t(scale(t(expMatrix.select))) #Generate the heatmap Heatmap( expMatrix.select.sc, col = colorRamp2(c(-2, 0, 2), c(&quot;#377EB8&quot;, &quot;white&quot;, &quot;#E41A1C&quot;)), name = &quot;Z score&quot;, cluster_columns = TRUE, cluster_rows = TRUE, top_annotation = ha, show_row_names = TRUE, show_column_names = FALSE, #Turned off column names row_names_gp = gpar(fontsize = 5), column_names_gp = gpar(fontsize = 5) ) Figure 6.3: Heatmap showing differentially expressed genes in Mayo-5289 after HNF4A KD 6.10 Gene Set Enrichment Analysis Over-representation and/or Gene Set Enrichment Analysis (GSEA) are essential tasks in any RNAseq study. These analyses help to define biological functions and/or processes that are enriched in different biological samples. In this section we will use the clusterProfiler package to perform over-representation analysis to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs). A comprehensive overview of the theory and methods used in this section is provided at the following location clusterProfiler-book or by typing browseVignettes(\"clusterProfiler\") at the R prompt. Please read through the clusterProfiler documentation. First load the clusterProfiler library into the current environment. library(clusterProfiler) For over-representation analysis, we require a vector of gene IDs. These gene IDs can be obtained by differential expression analysis (e.g. with the DESeq2 package). The functions that we will be using require Entrez IDs as input. We define a vector of significantly and differentially expressed Entrez IDs (genes) defining our experiment as follows: resMayo5289.enriched &lt;- subset(resMayo5289.Ordered, padj &lt;= 0.05) 6.10.1 KEGG KEGG (Kyoto Encyclopedia of Genes and Genomes) is a collection of databases dealing with genomes, biological pathways, diseases, drugs, and chemical substances. Our analysis will determine whether our experimentally derived gene list is enriched in any one of the curated gene sets defined by KEGG. To do this we will use the enrichKEGG function. #Perform the over-representation analysis using keggEnrich keggEnrich &lt;- enrichKEGG(gene = resMayo5289.enriched$entrez, organism = &#39;hsa&#39;, pvalueCutoff = 0.05) head(keggEnrich) #&gt; ID Description GeneRatio BgRatio #&gt; hsa04390 hsa04390 Hippo signaling pathway 52/1616 157/8108 #&gt; hsa05418 hsa05418 Fluid shear stress and atherosclerosis 47/1616 139/8108 #&gt; hsa05222 hsa05222 Small cell lung cancer 34/1616 92/8108 #&gt; hsa04068 hsa04068 FoxO signaling pathway 44/1616 131/8108 #&gt; hsa04115 hsa04115 p53 signaling pathway 28/1616 73/8108 #&gt; hsa00600 hsa00600 Sphingolipid metabolism 21/1616 49/8108 #&gt; pvalue p.adjust qvalue #&gt; hsa04390 6.014214e-05 0.01138331 0.008777407 #&gt; hsa05418 7.588034e-05 0.01138331 0.008777407 #&gt; hsa05222 1.046469e-04 0.01138331 0.008777407 #&gt; hsa04068 1.512923e-04 0.01138331 0.008777407 #&gt; hsa04115 2.017203e-04 0.01138331 0.008777407 #&gt; hsa00600 2.075984e-04 0.01138331 0.008777407 #&gt; geneID #&gt; hsa04390 595/166824/7474/84962/122786/330/652/7042/6657/6591/80326/71/3398/84612/1495/27113/1741/7532/25937/4092/4088/999/1490/5516/10413/1499/7476/7533/332/81029/5522/9231/8312/374/60/7534/23513/7004/329/1856/3996/2736/51176/7046/8324/60485/1454/5520/650/2535/7855/7473 #&gt; hsa05418 7850/4259/652/5154/858/71/2948/207/3162/7295/445/91860/801/8878/6300/3685/5747/3320/5879/1499/5599/7157/2938/9446/5602/60/6382/5562/5155/4780/1843/90/5563/10365/6613/1728/3326/2946/8503/6416/1535/9181/7422/805/3725/5600/4217 #&gt; hsa05222 595/3918/3909/1026/3673/3675/330/4616/1647/1284/207/3914/7187/6257/3685/598/1021/51426/3688/5747/54205/3913/836/7185/7157/1869/3655/329/1287/331/5728/8503/6502/1027 #&gt; hsa04068 595/1026/80854/901/7042/4616/9455/5106/1647/207/5565/604/6789/6300/4088/1263/6774/5599/10769/3276/6446/8743/4193/3643/3667/10110/5602/1956/5562/664/7046/5563/10365/6794/92579/1454/5728/8503/85417/51422/2308/6502/1027/5600 #&gt; hsa04115 595/1026/901/2810/64065/3732/4616/8795/5268/1647/27113/9540/598/1021/637/54205/64393/836/7157/8797/4193/50484/84883/3486/55240/5728/7249/51246 #&gt; hsa00600 2581/29956/8612/123099/57704/8877/9517/64781/81537/55627/2717/410/6609/8611/9514/8879/8560/2629/79603/55331/56848 #&gt; Count #&gt; hsa04390 52 #&gt; hsa05418 47 #&gt; hsa05222 34 #&gt; hsa04068 44 #&gt; hsa04115 28 #&gt; hsa00600 21 #Make the output biologist friendly keggEnrichRead &lt;- setReadable(keggEnrich, OrgDb = org.Hs.eg.db, keyType = &quot;ENTREZID&quot;) head(keggEnrichRead, 55) #&gt; ID Description GeneRatio BgRatio #&gt; hsa04390 hsa04390 Hippo signaling pathway 52/1616 157/8108 #&gt; hsa05418 hsa05418 Fluid shear stress and atherosclerosis 47/1616 139/8108 #&gt; hsa05222 hsa05222 Small cell lung cancer 34/1616 92/8108 #&gt; hsa04710 hsa04710 Circadian rhythm 13/1616 31/8108 #&gt; hsa05225 hsa05225 Hepatocellular carcinoma 48/1616 168/8108 #&gt; hsa01230 hsa01230 Biosynthesis of amino acids 25/1616 75/8108 #&gt; pvalue p.adjust qvalue #&gt; hsa04390 6.014214e-05 0.01138331 0.008777407 #&gt; hsa05418 7.588034e-05 0.01138331 0.008777407 #&gt; hsa05222 1.046469e-04 0.01138331 0.008777407 #&gt; hsa04710 4.181277e-03 0.04857691 0.037456517 #&gt; hsa05225 4.206647e-03 0.04857691 0.037456517 #&gt; hsa01230 4.281855e-03 0.04857691 0.037456517 #&gt; geneID #&gt; hsa04390 CCND1/RASSF6/WNT5A/AJUBA/FRMD6/BIRC3/BMP4/TGFB2/SOX2/SNAI2/WNT10A/ACTG1/ID2/PARD6B/CTNNA1/BBC3/DLG3/YWHAG/WWTR1/SMAD7/SMAD3/CDH1/CCN2/PPP2CB/YAP1/CTNNB1/WNT7A/YWHAH/BIRC5/WNT5B/PPP2R2C/DLG5/AXIN1/AREG/ACTB/YWHAZ/SCRIB/TEAD4/BIRC2/DVL2/LLGL1/GLI2/LEF1/TGFBR1/FZD7/SAV1/CSNK1E/PPP2R2A/BMP2/FZD2/FZD5/WNT3 #&gt; hsa05418 IL1R2/MGST3/BMP4/PDGFA/CAV2/ACTG1/GSTM4/AKT1/HMOX1/TXN/ASS1/CALML4/CALM1/SQSTM1/MAPK12/ITGAV/PTK2/HSP90AA1/RAC1/CTNNB1/MAPK8/TP53/GSTA1/GSTO1/MAPK10/ACTB/SDC1/PRKAA1/PDGFB/NFE2L2/DUSP1/ACVR1/PRKAA2/KLF2/SUMO2/NQO1/HSP90AB1/GSTM2/PIK3R3/MAP2K4/CYBA/ARHGEF2/VEGFA/CALM2/JUN/MAPK11/MAP3K5 #&gt; hsa05222 CCND1/LAMC2/LAMA3/CDKN1A/ITGA2/ITGA3/BIRC3/GADD45B/GADD45A/COL4A2/AKT1/LAMB3/TRAF3/RXRB/ITGAV/BCL2L1/CDK6/POLK/ITGB1/PTK2/CYCS/LAMB2/CASP3/TRAF1/TP53/E2F1/ITGA6/BIRC2/COL4A5/XIAP/PTEN/PIK3R3/SKP2/CDKN1B #&gt; hsa04710 BHLHE41/PRKAB2/PER3/CREB1/PER2/PER1/NR1D1/PRKAA1/CRY1/PRKAA2/RORC/CSNK1E/PRKAG2 #&gt; hsa05225 CCND1/CDKN1A/MGST3/WNT5A/FRAT2/TGFB2/GADD45B/WNT10A/TGFA/ACTG1/GADD45A/GSTM4/AKT1/HMOX1/MET/TXNRD1/BCL2L1/CDK6/POLK/SMAD3/SMARCE1/CTNNB1/WNT7A/WNT5B/TP53/AXIN1/E2F1/SMARCC1/GSTA1/GSTO1/BRD7/ACTB/EGFR/GAB1/DVL2/NFE2L2/LEF1/TGFBR1/NQO1/FZD7/PTEN/GSTM2/PIK3R3/FZD2/SMARCD2/FZD5/SMARCD3/WNT3 #&gt; hsa01230 PSAT1/GLUL/PFKL/GPT2/ACO2/ACO1/CBS/ASS1/SHMT1/PHGDH/RPIA/ASNS/ALDOB/TKT/IDH3A/IDH1/IDH2/PSPH/IDH3G/CS/ENO2/ENO1/PFKP/PC/PYCR3 #&gt; Count #&gt; hsa04390 52 #&gt; hsa05418 47 #&gt; hsa05222 34 #&gt; ...&lt;23 more rows&gt;... #&gt; hsa04710 13 #&gt; hsa05225 48 #&gt; hsa01230 25 6.10.2 REACTOME Like KEGG, the REACTOME database contains curated gene set annotations covering diverse molecular and cellular biology pathways. Similarly, our analysis will determine whether our experimentally derived gene list is enriched in any one of the curated gene sets defined by REACTOME. To do this we use the enrichPathway function provided by the ReactomePA package. library(ReactomePA) reactomeEnrich &lt;- enrichPathway( gene = resMayo5289.enriched$entrez, organism = &quot;human&quot;, pvalueCutoff = 0.05, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 0.2, minGSSize = 10, maxGSSize = 500, readable = TRUE ) head(reactomeEnrich, 5) #&gt; ID Description #&gt; R-HSA-1059683 R-HSA-1059683 Interleukin-6 signaling #&gt; R-HSA-112409 R-HSA-112409 RAF-independent MAPK1/3 activation #&gt; R-HSA-5357801 R-HSA-5357801 Programmed Cell Death #&gt; R-HSA-109581 R-HSA-109581 Apoptosis #&gt; R-HSA-5633008 R-HSA-5633008 TP53 Regulates Transcription of Cell Death Genes #&gt; GeneRatio BgRatio pvalue p.adjust qvalue #&gt; R-HSA-1059683 9/2199 11/10619 2.521779e-05 0.01521919 0.01419629 #&gt; R-HSA-112409 14/2199 23/10619 3.112841e-05 0.01521919 0.01419629 #&gt; R-HSA-5357801 60/2199 179/10619 3.891784e-05 0.01521919 0.01419629 #&gt; R-HSA-109581 59/2199 176/10619 4.485219e-05 0.01521919 0.01419629 #&gt; R-HSA-5633008 21/2199 44/10619 5.518197e-05 0.01521919 0.01419629 #&gt; geneID #&gt; R-HSA-1059683 SOCS3/IL6ST/STAT1/TYK2/IL6R/STAT3/JAK2/PTPN11/JAK1 #&gt; R-HSA-112409 IL6ST/DUSP4/TYK2/IL6R/JAK2/DUSP6/PTPN11/DUSP10/DUSP7/DUSP1/JAK1/PEA15/DUSP2/DUSP5 #&gt; R-HSA-5357801 CASP7/SFN/DSG3/BIRC3/TJP2/TNFRSF10B/PLEC/PSMB8/UACA/AKT1/MAGED1/NMT1/BBC3/BCL2L1/YWHAG/BID/CDH1/PTK2/TLR4/PSMC3/CTNNB1/RIPK1/CYCS/STAT3/MAPK8/PSME2/YWHAH/GSN/CASP3/DSP/PSMC4/H1F0/TP53/UNC5A/TNFRSF10A/TNFSF10/PSME1/E2F1/APIP/PPP3CC/PSMB9/YWHAZ/BMF/BIRC2/SPTAN1/ARHGAP10/APPL1/XIAP/UBB/HIST1H1C/DBNL/TJP1/FADD/PSMD7/TICAM1/PRKCQ/TP63/HIST1H1E/LMNB1/PSMD1 #&gt; R-HSA-109581 CASP7/SFN/DSG3/TJP2/TNFRSF10B/PLEC/PSMB8/UACA/AKT1/MAGED1/NMT1/BBC3/BCL2L1/YWHAG/BID/CDH1/PTK2/TLR4/PSMC3/CTNNB1/RIPK1/CYCS/STAT3/MAPK8/PSME2/YWHAH/GSN/CASP3/DSP/PSMC4/H1F0/TP53/UNC5A/TNFRSF10A/TNFSF10/PSME1/E2F1/APIP/PPP3CC/PSMB9/YWHAZ/BMF/BIRC2/SPTAN1/ARHGAP10/APPL1/XIAP/UBB/HIST1H1C/DBNL/TJP1/FADD/PSMD7/TICAM1/PRKCQ/TP63/HIST1H1E/LMNB1/PSMD1 #&gt; R-HSA-5633008 PERP/TNFRSF10B/TP53INP1/BCL6/BBC3/TP53I3/BID/PRELID1/CASP10/CASP1/BIRC5/TP53/BNIP3L/TNFRSF10A/NDRG1/AIFM2/IGFBP3/STEAP3/RABGGTB/TP63/TNFRSF10D #&gt; Count #&gt; R-HSA-1059683 9 #&gt; R-HSA-112409 14 #&gt; R-HSA-5357801 60 #&gt; R-HSA-109581 59 #&gt; R-HSA-5633008 21 6.10.3 Plotting functions Once we have our results, we would like to generate publication quality figures. The clusterProfiler and enrichPlot packages provide a number of plotting functions that make this easy. Dotplot library(enrichplot) plot1 &lt;- dotplot(keggEnrich, showCategory = 10) + ggtitle(&quot;KEGG&quot;) #&gt; wrong orderBy parameter; set to default `orderBy = &quot;x&quot;` plot2 &lt;- dotplot(reactomeEnrich, showCategory = 10) + ggtitle(&quot;REACTOME&quot;) #&gt; wrong orderBy parameter; set to default `orderBy = &quot;x&quot;` plot_grid(plot1, plot2, ncol = 2) Figure 6.4: Dotplot showing KEGG and REACTOME pathways that are significantly enriched. Upset plot An upsetplot shows the overlap of genes comprising different gene sets and provides a complex overview of genes and gene sets significantly enriched in the experiment. upsetplot(reactomeEnrich) Figure 6.5: UpSet plot showing the overlap of genes comprising significantly enriched processes and pathways. Enrichment map plot An enrichment map plot emapplot generates a network of significantly enriched gene sets with edges connecting overlapping gene sets. emapplot(reactomeEnrich) Figure 6.6: Enrichment map of Reactome pathways significantly enriched. 6.10.4 Extracting enrichment results to generate heatmaps The above analysis showed that our experimentally derived gene list is significantly enriched in the “Transcriptional Regulation by TP53” REACTOME gene set. Because we have selected genes that are both up and down regulated following HNF4A KD, we would like to understand how specific genes, within this pathway, are modulated by HNF4A. A heatmap is an informative way of determining the relative expression of sets of genes, so let’s generate a heatmap using the set of genes comprising this pathway. First, we need to get the data into the correct shape as follows: slotNames(reactomeEnrich) #&gt; [1] &quot;result&quot; &quot;pvalueCutoff&quot; &quot;pAdjustMethod&quot; &quot;qvalueCutoff&quot; #&gt; [5] &quot;organism&quot; &quot;ontology&quot; &quot;gene&quot; &quot;keytype&quot; #&gt; [9] &quot;universe&quot; &quot;gene2Symbol&quot; &quot;geneSets&quot; &quot;readable&quot; reactResults &lt;- reactomeEnrich@result tp53genes &lt;- subset(reactResults, Description == &quot;Transcriptional Regulation by TP53&quot;)$geneID tp53genes.vector &lt;- strsplit(tp53genes, &quot;/&quot;)[[1]] expMatrix &lt;- assay(vsd) rownames(expMatrix) &lt;- mapIds( org.Hs.eg.db, keys = rownames(expMatrix), column = &quot;SYMBOL&quot;, keytype = &quot;ENSEMBL&quot;, multiVals = &quot;first&quot; ) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #Map the significant results to the transformed expression values inter &lt;- intersect(rownames(expMatrix), tp53genes.vector) expMatrix.tp53 &lt;- expMatrix[inter,] #Add human readable gene names expMatrix.tp53 &lt;- expMatrix.tp53[, grepl(&quot;Mayo_5289_HNF4A|Mayo_5289_Cont&quot;, colData(dds)$Treatment_group)] #Give the matrix some useful column names colnames(expMatrix.tp53) &lt;- colData(dds)[colnames(expMatrix.tp53), &quot;Treatment_group&quot;] Notice that we have used the strsplit function to split the character string tp53genes into a vector of gene symbols! Now produce the heatmap using the ComplexHeatmap package: #Setup the annotation showing treatment type ha &lt;- HeatmapAnnotation(Treatment = colnames(expMatrix.tp53), col = list(Treatment = structure( names = c(&quot;Mayo_5289_Cont&quot;, &quot;Mayo_5289_HNF4A&quot;), colors[3:4] ))) #Scale the matrix to generate z-scores expMatrix.tp53.sc &lt;- t(scale(t(expMatrix.tp53))) #Generate the heatmap Heatmap( expMatrix.tp53.sc, col = colorRamp2(c(-2, 0, 2), c(&quot;#377EB8&quot;, &quot;white&quot;, &quot;#E41A1C&quot;)), name = &quot;Z score&quot;, cluster_columns = TRUE, cluster_rows = TRUE, top_annotation = ha, show_row_names = TRUE, show_column_names = FALSE, #Turned off column names row_names_gp = gpar(fontsize = 5), column_names_gp = gpar(fontsize = 5) ) Figure 6.7: Heatmap showing differentially expressed genes in the Transcriptional Regulation by TP53 Reactome pathway "],["cancer-dependency-map-depmap.html", "Chapter 7 Cancer Dependency Map - DepMap 7.1 Downloading DepMap data using the depmap package 7.2 Exploring DepMap transcriptomic data 7.3 Exploring DepMap mutation calls 7.4 Exploring DepMap CRISPR data", " Chapter 7 Cancer Dependency Map - DepMap Chapter 7 will explore the Cancer Dependency Map or DepMap data resource. DepMap provides a comprehensive set of data including genomic information and screening data for gene and small molecule perturbations across hundreds of cancer cell line models. By triangulating information from these and other large-scale datasets, the hope is to define a landscape of genetic targets for therapeutic development, identify patients who respond to these therapies, and develop a better understanding of the vulnerabilities of cancer. 7.1 Downloading DepMap data using the depmap package DepMap data can downloaded directly from the DepMap data portal website. Alternatively, DepMap data can be downloaded from within R using the Bioconductor package depmap. depmap provides easy access to datasets from the most current DepMap release, including RNAi and CRISPR-Cas9 gene knockout screens quantifying the genetic dependency for select cancer cell lines. Additional datasets are also available including log copy number of genes for select cell lines, protein expression of cell lines as measured by reverse phase protein lysate microarray (RPPA), ‘Transcript Per Million’ (TPM) data, as well as supplementary datasets which contain metadata and mutation calls for the other datasets found in the current release. The 19Q3 release adds the drug_dependency dataset, that contains cancer cell line dependency data with respect to drug and drug-candidate compounds. The 20Q2 release adds the proteomic dataset that contains quantitative profiling of proteins via mass spectrometry. First install the depmap package as follows: BiocManager::install(&quot;depmap&quot;) Load the depmap and ExperimentHub libraries into your working environment: library(&quot;depmap&quot;) library(&quot;ExperimentHub&quot;) First we create an ExperimentHub object called eh and generate a query using the depmap argument to obtain a list of DepMap data that are available for download: eh &lt;- ExperimentHub() #&gt; snapshotDate(): 2021-05-18 query(eh, &quot;depmap&quot;) #&gt; ExperimentHub with 58 records #&gt; # snapshotDate(): 2021-05-18 #&gt; # $dataprovider: Broad Institute #&gt; # $species: Homo sapiens #&gt; # $rdataclass: tibble #&gt; # additional mcols(): taxonomyid, genome, description, #&gt; # coordinate_1_based, maintainer, rdatadateadded, preparerclass, #&gt; # tags, rdatapath, sourceurl, sourcetype #&gt; # retrieve records with, e.g., &#39;object[[&quot;EH2260&quot;]]&#39; #&gt; #&gt; title #&gt; EH2260 | rnai_19Q1 #&gt; EH2261 | crispr_19Q1 #&gt; EH2262 | copyNumber_19Q1 #&gt; EH2263 | RPPA_19Q1 #&gt; EH2264 | TPM_19Q1 #&gt; ... ... #&gt; EH6118 | crispr_21Q2 #&gt; EH6119 | copyNumber_21Q2 #&gt; EH6120 | TPM_21Q2 #&gt; EH6121 | mutationCalls_21Q2 #&gt; EH6122 | metadata_21Q2 To retrieve a dataset of interest we can simply use the name of the list element. For example, let’s obtain the DepMap transcriptomic data as follows: TPM &lt;- eh[[&quot;EH6120&quot;]] #&gt; see ?depmap and browseVignettes(&#39;depmap&#39;) for documentation #&gt; downloading 1 resources #&gt; retrieving 1 resource #&gt; loading from cache head(TPM) #&gt; # A tibble: 6 x 6 #&gt; depmap_id gene rna_expression entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-001113 TSPAN6 (71… 4.99 7105 TSPAN6 LC1SQSF_LUNG #&gt; 2 ACH-001289 TSPAN6 (71… 5.21 7105 TSPAN6 COGAR359_SOFT_TI… #&gt; 3 ACH-001339 TSPAN6 (71… 3.78 7105 TSPAN6 COLO794_SKIN #&gt; 4 ACH-001538 TSPAN6 (71… 5.73 7105 TSPAN6 KKU213_BILIARY_T… #&gt; 5 ACH-000242 TSPAN6 (71… 7.47 7105 TSPAN6 RT4_URINARY_TRACT #&gt; 6 ACH-000708 TSPAN6 (71… 4.91 7105 TSPAN6 SNU283_LARGE_INT… We can also obtain detailed information about each of the cell lines by downloading the metadata: metaData &lt;- eh[[&quot;EH6122&quot;]] #&gt; see ?depmap and browseVignettes(&#39;depmap&#39;) for documentation #&gt; loading from cache head(metaData) #&gt; # A tibble: 6 x 26 #&gt; depmap_id cell_line_name stripped_cell_l… cell_line aliases cosmic_id sex #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 ACH-0000… NIH:OVCAR-3 NIHOVCAR3 NIHOVCAR… OVCAR3 905933 Fema… #&gt; 2 ACH-0000… HL-60 HL60 HL60_HAE… &lt;NA&gt; 905938 Fema… #&gt; 3 ACH-0000… CACO2 CACO2 CACO2_LA… CACO2,… NA Male #&gt; 4 ACH-0000… HEL HEL HEL_HAEM… &lt;NA&gt; 907053 Male #&gt; 5 ACH-0000… HEL 92.1.7 HEL9217 HEL9217_… &lt;NA&gt; NA Male #&gt; 6 ACH-0000… MONO-MAC-6 MONOMAC6 MONOMAC6… &lt;NA&gt; 908148 Male #&gt; # … with 19 more variables: source &lt;chr&gt;, Achilles_n_replicates &lt;dbl&gt;, #&gt; # cell_line_NNMD &lt;dbl&gt;, culture_type &lt;chr&gt;, culture_medium &lt;chr&gt;, #&gt; # cas9_activity &lt;dbl&gt;, RRID &lt;chr&gt;, WTSI_master_cell_ID &lt;dbl&gt;, #&gt; # sample_collection_site &lt;chr&gt;, primary_or_metastasis &lt;chr&gt;, #&gt; # primary_disease &lt;chr&gt;, subtype_disease &lt;chr&gt;, age &lt;dbl&gt;, #&gt; # sanger_id &lt;chr&gt;, additional_info &lt;lgl&gt;, lineage &lt;chr&gt;, #&gt; # lineage_subtype &lt;chr&gt;, lineage_sub_subtype &lt;chr&gt;, #&gt; # lineage_molecular_subtype &lt;chr&gt; We might for instance be interested in obtaining the lineage of each cell line: lineages &lt;- metaData %&gt;% select(lineage) %&gt;% unique() lineages$lineage #&gt; [1] &quot;ovary&quot; &quot;blood&quot; #&gt; [3] &quot;colorectal&quot; &quot;skin&quot; #&gt; [5] &quot;lung&quot; &quot;urinary_tract&quot; #&gt; ... #&gt; [35] &quot;adrenal_cortex&quot; &quot;epidermoid_carcinoma&quot; #&gt; [37] &quot;embryo&quot; &quot;engineered&quot; #&gt; [39] &quot;engineered_blood&quot; Have you noticed a new way of coding? We are using the dplyr package. What are these %&gt;% functions? %&gt;% functions are pipes that allow us to pass data from one function to another without the hassle of assigning multiple objects. The dplyr package includes a number of extremely useful functions that allow us to join different tables and integrate related datasets! 7.2 Exploring DepMap transcriptomic data What if we are interested in examining GATA6 expression across cancer cell lineages? How can we achieve this? Firstly, we notice that the lineage specific information is found in the metaData object while the gene expression data is located in the TPM object. We can join the tables using the dplyr::full_join function as follows: expBylineage &lt;- metaData %&gt;% dplyr::select(depmap_id, lineage) %&gt;% dplyr::full_join(TPM, by = &quot;depmap_id&quot;) head(expBylineage) #&gt; # A tibble: 6 x 7 #&gt; depmap_id lineage gene rna_expression entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000001 ovary TSPAN6 (… 5.82 7105 TSPAN6 NIHOVCAR3_… #&gt; 2 ACH-000001 ovary TNMD (64… 0 64102 TNMD NIHOVCAR3_… #&gt; 3 ACH-000001 ovary DPM1 (88… 7.37 8813 DPM1 NIHOVCAR3_… #&gt; 4 ACH-000001 ovary SCYL3 (5… 2.10 57147 SCYL3 NIHOVCAR3_… #&gt; 5 ACH-000001 ovary C1orf112… 4.22 55732 C1orf112 NIHOVCAR3_… #&gt; 6 ACH-000001 ovary FGR (226… 0.0426 2268 FGR NIHOVCAR3_… To extract GATA6 gene expression data we can use the dplyr::filter() function: gata6Bylineage &lt;- expBylineage %&gt;% dplyr::filter(gene_name == &quot;GATA6&quot;) head(gata6Bylineage) #&gt; # A tibble: 6 x 7 #&gt; depmap_id lineage gene rna_expression entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000001 ovary GATA6… 1.27 2627 GATA6 NIHOVCAR3_OVA… #&gt; 2 ACH-000002 blood GATA6… 0 2627 GATA6 HL60_HAEMATOP… #&gt; 3 ACH-000003 colore… GATA6… 5.91 2627 GATA6 CACO2_LARGE_I… #&gt; 4 ACH-000004 blood GATA6… 0.0704 2627 GATA6 HEL_HAEMATOPO… #&gt; 5 ACH-000005 blood GATA6… 0.202 2627 GATA6 HEL9217_HAEMA… #&gt; 6 ACH-000006 blood GATA6… 0 2627 GATA6 MONOMAC6_HAEM… Using the descriptive plotting skills that you learned in Chapter 4 generate a boxplot to determine whether GATA6 gene expression is specifically enriched in a cell line lineage. library(ggpubr) ggboxplot(gata6Bylineage, x = &quot;lineage&quot;, y = &quot;rna_expression&quot;, title = &quot;GATA6 Expression by Cell Line Lineage&quot;, ylab = &quot;Expression (TPM)&quot;, color = &quot;lineage&quot;) + rotate_x_text() Figure 7.1: Boxplot of GATA6 expression (TPM) by cell lineage We might also be interested in the relative expression of GATA6 in different Pancreatic Cancer cell lines. We can generate a barplot to show the relative expression levels as follows: gata6BylPancreas &lt;- gata6Bylineage %&gt;% filter(lineage==&quot;pancreas&quot;) gata6BylPancreas %&gt;% head() #&gt; # A tibble: 6 x 7 #&gt; depmap_id lineage gene rna_expression entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000022 pancreas GATA6 … 5.23 2627 GATA6 PATU8988S_P… #&gt; 2 ACH-000023 pancreas GATA6 … 0.333 2627 GATA6 PATU8988T_P… #&gt; 3 ACH-000031 pancreas GATA6 … 2.99 2627 GATA6 PANC0213_PA… #&gt; 4 ACH-000042 pancreas GATA6 … 1.03 2627 GATA6 PANC0203_PA… #&gt; 5 ACH-000060 pancreas GATA6 … 0.310 2627 GATA6 PANC1005_PA… #&gt; 6 ACH-000085 pancreas GATA6 … 2.74 2627 GATA6 T3M4_PANCRE… Generate a barplot using the ggbarplot function with expression values plotted in descending order: ggbarplot(gata6BylPancreas, x = &quot;cell_line&quot;, y=&quot;rna_expression&quot;, fill = &quot;seashell3&quot;, sort.val = &quot;desc&quot;, title = &quot;GATA6 Expression in Pancreatic Cancer Cell lines&quot;, ylab = &quot;Expression (TPM)&quot;, xlab = &quot;Pancreatic Cancer Cell Lines &quot;) + rotate_x_text() Figure 7.2: Barplot of GATA6 expression (TPM) in Pancreatic Cancer Cell lines 7.3 Exploring DepMap mutation calls First, let’s extract the 21Q2 DepMap mutation calls: mutData &lt;- eh[[&quot;EH6121&quot;]] #&gt; see ?depmap and browseVignettes(&#39;depmap&#39;) for documentation #&gt; loading from cache mutBylineage &lt;- metaData %&gt;% dplyr::select(depmap_id, lineage, cell_line_name) %&gt;% dplyr::full_join(mutData, by = &quot;depmap_id&quot;) head(mutBylineage) #&gt; # A tibble: 6 x 34 #&gt; depmap_id lineage cell_line_name gene_name entrez_id ncbi_build chromosome #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 ACH-000001 ovary NIH:OVCAR-3 VPS13D 55187 37 1 #&gt; 2 ACH-000001 ovary NIH:OVCAR-3 AADACL4 343066 37 1 #&gt; 3 ACH-000001 ovary NIH:OVCAR-3 IFNLR1 163702 37 1 #&gt; 4 ACH-000001 ovary NIH:OVCAR-3 TMEM57 55219 37 1 #&gt; 5 ACH-000001 ovary NIH:OVCAR-3 ZSCAN20 7579 37 1 #&gt; 6 ACH-000001 ovary NIH:OVCAR-3 POU3F1 5453 37 1 #&gt; # … with 27 more variables: start_pos &lt;dbl&gt;, end_pos &lt;dbl&gt;, strand &lt;chr&gt;, #&gt; # var_class &lt;chr&gt;, var_type &lt;chr&gt;, ref_allele &lt;chr&gt;, #&gt; # tumor_seq_allele1 &lt;chr&gt;, dbSNP_RS &lt;chr&gt;, dbSNP_val_status &lt;chr&gt;, #&gt; # genome_change &lt;chr&gt;, annotation_trans &lt;chr&gt;, cDNA_change &lt;chr&gt;, #&gt; # codon_change &lt;chr&gt;, protein_change &lt;chr&gt;, is_deleterious &lt;lgl&gt;, #&gt; # is_tcga_hotspot &lt;lgl&gt;, tcga_hsCnt &lt;dbl&gt;, is_cosmic_hotspot &lt;lgl&gt;, #&gt; # cosmic_hsCnt &lt;dbl&gt;, ExAC_AF &lt;dbl&gt;, var_annotation &lt;chr&gt;, #&gt; # CGA_WES_AC &lt;chr&gt;, HC_AC &lt;chr&gt;, RD_AC &lt;chr&gt;, RNAseq_AC &lt;chr&gt;, #&gt; # sanger_WES_AC &lt;chr&gt;, WGS_AC &lt;chr&gt; The maftools package provides a number of useful functions for exploring and analyzing mutation calls. Before we can use maftools we need to modify some of the column names. mutBylineageRename &lt;- mutBylineage %&gt;% rename(Hugo_Symbol=gene_name) %&gt;% rename(Start_Position=start_pos) %&gt;% rename(End_Position=end_pos) %&gt;% rename(Variant_Classification=var_class) %&gt;% rename(Variant_Type=var_type) %&gt;% rename(Reference_Allele=ref_allele) %&gt;% rename(Tumor_Seq_Allele2 = tumor_seq_allele1) %&gt;% rename(Tumor_Sample_Barcode = cell_line_name) Create a mafObject using our renamed table: library(maftools) mafObject &lt;- read.maf(mutBylineageRename, rmFlags = TRUE) #&gt; -Validating #&gt; --Removed 567 duplicated variants #&gt; --Found 46 variants with no Gene Symbols #&gt; --Annotating them as &#39;UnknownGene&#39; for convenience #&gt; --Non MAF specific values in Variant_Classification column: #&gt; Start_Codon_Del #&gt; Stop_Codon_Ins #&gt; NA #&gt; --Non MAF specific values in Variant_Type column: #&gt; NA #&gt; -Removing 20 FLAG genes #&gt; -Silent variants: 397886 #&gt; -Summarizing #&gt; -Processing clinical data #&gt; --Missing clinical data #&gt; -Finished in 32.7s elapsed (28.5s cpu) Subset the mafObject to select only pancreatic cell lines and genes that are know pancreatic cancer drivers. drivers &lt;- c(&quot;TP53,SMAD4,KRAS,RNF43,ARID1A,CDKN2A,TGFBR2,ACVR1B,KDM6A,MLL3,ACVR2A,SMARCA4,MAP2K4,SMAD3,RBM10,SF3B1,MARK2,TGFBR1,SDK2,PBRM1,U2AF1,FBXW7,ATM,TP53BP2,CALD1,BCORL1,FBLN2,PLXNB2,SIN3B,MACF1,DISP2,KALRN,ITPR3,HIVEP1,MYCBP2,NF2,SETD2,SPTB,NBEA,TLE4,JAG1,BRCA1,BRCA2,RPA1,PALB2&quot;) drivers &lt;- unlist(strsplit(drivers, &quot;,&quot;)[[1]]) mafPanc &lt;- subsetMaf(mafObject, query=&quot;lineage == &#39;pancreas&#39;&quot;, genes = drivers) #&gt; -Processing clinical data mafPanc #&gt; An object of class MAF #&gt; ID summary Mean Median #&gt; 1: NCBI_Build NA NA NA #&gt; 2: Center NA NA NA #&gt; 3: Samples 56 NA NA #&gt; 4: nGenes 37 NA NA #&gt; 5: Frame_Shift_Del 25 0.446 0.0 #&gt; 6: Frame_Shift_Ins 24 0.429 0.0 #&gt; 7: In_Frame_Del 4 0.071 0.0 #&gt; 8: In_Frame_Ins 2 0.036 0.0 #&gt; 9: Missense_Mutation 156 2.786 2.5 #&gt; 10: Nonsense_Mutation 23 0.411 0.0 #&gt; 11: Splice_Site 12 0.214 0.0 #&gt; 12: total 246 4.393 4.0 Plot a summary of the mutation calls: plotmafSummary(maf = mafPanc, rmOutlier = TRUE, addStat = &#39;median&#39;, dashboard = TRUE, titvRaw = FALSE) Figure 7.3: Summary of mutations found in Pancreatic Cancer Cell Lines Generate an oncoplot of the top 20 mutations: oncoplot(maf = mafPanc, top = 20, showTumorSampleBarcodes = TRUE, SampleNamefontSize = 0.5) Figure 7.4: Summary of mutations found in Pancreatic Cancer Cell Lines 7.4 Exploring DepMap CRISPR data crispData &lt;- eh[[&quot;EH6118&quot;]] #&gt; see ?depmap and browseVignettes(&#39;depmap&#39;) for documentation #&gt; loading from cache head(crispData) #&gt; # A tibble: 6 x 6 #&gt; depmap_id gene dependency entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000001 A1BG (… -0.335 1 A1BG NIHOVCAR3_OVARY #&gt; 2 ACH-000004 A1BG (… 0.0201 1 A1BG HEL_HAEMATOPOIETIC_AND_L… #&gt; 3 ACH-000005 A1BG (… -0.191 1 A1BG HEL9217_HAEMATOPOIETIC_A… #&gt; 4 ACH-000007 A1BG (… 0.00886 1 A1BG LS513_LARGE_INTESTINE #&gt; 5 ACH-000009 A1BG (… 0.00648 1 A1BG C2BBE1_LARGE_INTESTINE #&gt; 6 ACH-000011 A1BG (… 0.145 1 A1BG 253J_URINARY_TRACT Join with metadata. crispBylineage &lt;- metaData %&gt;% dplyr::select(depmap_id, lineage) %&gt;% dplyr::full_join(crispData, by = &quot;depmap_id&quot;) head(crispBylineage) #&gt; # A tibble: 6 x 7 #&gt; depmap_id lineage gene dependency entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000001 ovary A1BG (1) -0.335 1 A1BG NIHOVCAR3_O… #&gt; 2 ACH-000001 ovary A1CF (29974) -0.0616 29974 A1CF NIHOVCAR3_O… #&gt; 3 ACH-000001 ovary A2M (2) -0.0269 2 A2M NIHOVCAR3_O… #&gt; 4 ACH-000001 ovary A2ML1 (1445… -0.0265 144568 A2ML1 NIHOVCAR3_O… #&gt; 5 ACH-000001 ovary A3GALT2 (12… -0.130 127550 A3GALT2 NIHOVCAR3_O… #&gt; 6 ACH-000001 ovary A4GALT (539… 0.0607 53947 A4GALT NIHOVCAR3_O… Filter to select GATA6 and Pancreatic Cancer Cell Lines gata6CrispPanc &lt;- crispBylineage %&gt;% dplyr::filter(gene_name == &quot;GATA6&quot;) %&gt;% dplyr::filter(lineage == &quot;pancreas&quot;) head(gata6CrispPanc) #&gt; # A tibble: 6 x 7 #&gt; depmap_id lineage gene dependency entrez_id gene_name cell_line #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ACH-000022 pancreas GATA6 (2… -0.476 2627 GATA6 PATU8988S_PAN… #&gt; 2 ACH-000023 pancreas GATA6 (2… 0.210 2627 GATA6 PATU8988T_PAN… #&gt; 3 ACH-000042 pancreas GATA6 (2… -0.0438 2627 GATA6 PANC0203_PANC… #&gt; 4 ACH-000060 pancreas GATA6 (2… -0.0412 2627 GATA6 PANC1005_PANC… #&gt; 5 ACH-000085 pancreas GATA6 (2… -0.0496 2627 GATA6 T3M4_PANCREAS #&gt; 6 ACH-000093 pancreas GATA6 (2… 0.00316 2627 GATA6 PANC0504_PANC… Join GATA6 Expression and GATA6 CRISPRi tables to obtain final table. gata6CrispExpPanc &lt;- gata6CrispPanc %&gt;% dplyr::full_join(gata6BylPancreas, by = &quot;depmap_id&quot;) Generate a Scatter Plot using the ggscatter function with added labels. ggscatter(gata6CrispExpPanc, x = &quot;dependency&quot;, y = &quot;rna_expression&quot;, size = 0.6, rug = TRUE, # Add marginal rug add = &quot;reg.line&quot;, label = &quot;cell_line.x&quot;, repel = TRUE, font.label = list(size = 9, face = &quot;italic&quot;), ylab = &quot;GATA6 Expression (TPM)&quot;, xlab = &quot;GATA6 CRISPRi Dependency&quot; ) Figure 7.5: GATA6 Expression versus CRISPRi Dependency in Pancreatic Cancer Cell Lines Generate a Scatter Plot using the ggscatter function showing only those cell lines that have high GATA6 gene expression and GATA6 dependency. Let’s also determine the significance of the correlation. label.select.criteria &lt;- list(criteria = &quot;`dependency` &lt; -0.2 &amp; `rna_expression` &gt;= 3&quot;) ggscatter(gata6CrispExpPanc, x = &quot;dependency&quot;, y = &quot;rna_expression&quot;, size = 0.6, rug = TRUE, label.select = label.select.criteria, font.label = list(size = 9, face = &quot;italic&quot;), add = &quot;reg.line&quot;, label = &quot;cell_line.x&quot;, repel = TRUE, cor.coef = TRUE, cor.coeff.args = list(method = &quot;pearson&quot;, label.x = 0.25, label.sep = &quot;\\n&quot;), ylab = &quot;GATA6 Expression (TPM)&quot;, xlab = &quot;GATA6 CRISPRi Dependency&quot;) Figure 7.6: GATA6 Expression versus CRISPRi Dependency in Pancreatic Cancer Cell Lines "]]
